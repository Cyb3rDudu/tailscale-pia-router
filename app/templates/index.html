<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>PIA Router</title>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/uplot@1.6.32/dist/uPlot.iife.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/uplot@1.6.32/dist/uPlot.min.css">
    <script>
        tailwind.config = {
            darkMode: 'media'
        }
    </script>
    <style>
        .network-link {
            stroke: #3b82f6;
            stroke-width: 2px;
            fill: none;
            marker-end: url(#arrowhead);
        }
        .network-node {
            cursor: pointer;
        }
        .network-node circle {
            stroke: #fff;
            stroke-width: 2px;
        }
        .network-node text {
            font-size: 12px;
            pointer-events: none;
            fill: #1f2937;
        }
        @media (prefers-color-scheme: dark) {
            .network-node text {
                fill: #f9fafb;
            }
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900" x-data="app()" x-init="init()">
    <div class="min-h-screen">
        <!-- Header -->
        <header class="bg-white dark:bg-gray-800 shadow">
            <div class="max-w-7xl mx-auto px-4 py-4 sm:py-6 sm:px-6 lg:px-8">
                <div class="flex flex-col sm:flex-row sm:justify-between sm:items-center space-y-3 sm:space-y-0">
                    <h1 class="text-2xl sm:text-3xl font-bold text-gray-900 dark:text-white">PIA Router</h1>
                    <div class="flex items-center justify-between sm:justify-end space-x-3 sm:space-x-6">
                        <!-- Compact Status Indicators -->
                        <div class="flex items-center space-x-2">
                            <div :class="vpnStatus.active_count > 0 ? 'bg-green-500' : 'bg-gray-500'" class="w-2.5 h-2.5 rounded-full"></div>
                            <span class="text-xs sm:text-sm text-gray-700 dark:text-gray-300">
                                <span x-text="vpnStatus.active_count"></span> <span class="hidden sm:inline">VPN</span>
                            </span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <div :class="tailscaleStatus.running ? 'bg-green-500' : 'bg-red-500'" class="w-2.5 h-2.5 rounded-full"></div>
                            <span class="text-xs sm:text-sm text-gray-700 dark:text-gray-300"><span class="hidden sm:inline">Tailscale</span><span class="sm:hidden">TS</span></span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <div :class="systemHealth.healthy ? 'bg-green-500' : 'bg-yellow-500'" class="w-2.5 h-2.5 rounded-full"></div>
                            <span class="text-xs sm:text-sm text-gray-700 dark:text-gray-300"><span class="hidden sm:inline">System</span><span class="sm:hidden">Sys</span></span>
                        </div>
                        <a href="/settings" class="text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300 text-xs sm:text-sm font-medium">Settings</a>
                    </div>
                </div>
            </div>
        </header>

        <main class="max-w-7xl mx-auto px-4 py-4 sm:py-6 sm:px-6 lg:px-8">
            <!-- VPN Connection Cards Grid -->
            <div x-show="vpnStatus.connections && vpnStatus.connections.length > 0">
                <h2 class="text-lg sm:text-xl font-semibold text-gray-900 dark:text-white mb-3 sm:mb-4">VPN Connections</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 sm:gap-6 mb-4 sm:mb-6">
                    <template x-for="conn in vpnStatus.connections" :key="conn.region_id">
                        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-4 sm:p-6">
                            <!-- Connection Header -->
                            <div class="flex items-center justify-between mb-3 sm:mb-4">
                                <div>
                                    <h3 class="text-base sm:text-lg font-semibold text-gray-900 dark:text-white" x-text="conn.region_name"></h3>
                                    <p class="text-xs text-gray-500 dark:text-gray-400" x-text="conn.interface"></p>
                                </div>
                                <div class="bg-green-500 w-3 h-3 rounded-full flex-shrink-0"></div>
                            </div>

                            <!-- Stats -->
                            <div class="space-y-2 mb-4">
                                <div class="flex justify-between text-sm">
                                    <span class="text-gray-600 dark:text-gray-400">Last Handshake</span>
                                    <span class="text-gray-900 dark:text-white font-medium" x-text="conn.last_handshake || 'N/A'"></span>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <span class="text-gray-600 dark:text-gray-400">Total ↓</span>
                                    <span class="text-gray-900 dark:text-white font-medium" x-text="conn.transfer_rx || '0 B'"></span>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <span class="text-gray-600 dark:text-gray-400">Total ↑</span>
                                    <span class="text-gray-900 dark:text-white font-medium" x-text="conn.transfer_tx || '0 B'"></span>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <span class="text-gray-600 dark:text-gray-400">Current ↓</span>
                                    <span class="text-green-600 dark:text-green-400 font-medium" x-text="formatRate(getCurrentRate(conn.interface, 'rx'))"></span>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <span class="text-gray-600 dark:text-gray-400">Current ↑</span>
                                    <span class="text-blue-600 dark:text-blue-400 font-medium" x-text="formatRate(getCurrentRate(conn.interface, 'tx'))"></span>
                                </div>
                            </div>

                            <!-- Throughput Chart -->
                            <div class="mt-3 sm:mt-4">
                                <div class="text-xs text-gray-500 dark:text-gray-400 mb-2">Throughput (last 2 minutes)</div>
                                <div :id="'chart-' + conn.interface" class="touch-pan-y" style="height: 120px; min-height: 120px;"></div>
                            </div>

                            <!-- Devices using this connection -->
                            <div class="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
                                <div class="text-xs font-medium text-gray-700 dark:text-gray-300 mb-2">Devices</div>
                                <div class="space-y-1">
                                    <template x-for="device in devices.filter(d => d.region_id === conn.region_id)" :key="device.id">
                                        <div class="text-xs text-gray-600 dark:text-gray-400 flex items-center space-x-1">
                                            <div :class="device.online ? 'bg-green-500' : 'bg-gray-500'" class="w-1.5 h-1.5 rounded-full"></div>
                                            <span x-text="device.hostname"></span>
                                        </div>
                                    </template>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>
            </div>

            <!-- Network Topology Mesh - Hide on mobile -->
            <div class="hidden md:block bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-6">
                <h2 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Network Topology</h2>
                <div id="network-graph" class="w-full bg-gray-100 dark:bg-gray-700 rounded" style="height: 400px;"></div>
            </div>

            <!-- Device List -->
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-4 sm:p-6">
                <h2 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Tailscale Devices</h2>

                <!-- Mobile Card Layout -->
                <div class="md:hidden space-y-4">
                    <template x-for="device in devices" :key="device.id">
                        <div class="bg-gray-50 dark:bg-gray-700 rounded-lg p-4 space-y-3">
                            <div class="flex justify-between items-start">
                                <div>
                                    <h3 class="text-sm font-medium text-gray-900 dark:text-white" x-text="device.hostname"></h3>
                                    <p class="text-xs text-gray-500 dark:text-gray-400 mt-1" x-text="device.ip_addresses.join(', ')"></p>
                                </div>
                                <span :class="device.online ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200' : 'bg-gray-100 text-gray-800 dark:bg-gray-600 dark:text-gray-300'" class="px-2 py-1 text-xs rounded-full" x-text="device.online ? 'Online' : 'Offline'"></span>
                            </div>
                            <div class="text-xs text-gray-600 dark:text-gray-400">
                                <span class="font-medium">OS:</span> <span x-text="device.os || 'Unknown'"></span>
                            </div>
                            <div class="space-y-2">
                                <!-- Searchable Region Dropdown -->
                                <div>
                                    <label class="block text-xs font-medium text-gray-700 dark:text-gray-300 mb-1">VPN Region</label>
                                    <div x-data="{
                                        open: false,
                                        search: '',
                                        get filteredRegions() {
                                            if (!this.search) return regions;
                                            const searchLower = this.search.toLowerCase();
                                            return regions.filter(r =>
                                                r.name.toLowerCase().includes(searchLower) ||
                                                r.country.toLowerCase().includes(searchLower)
                                            );
                                        },
                                        selectRegion(regionId) {
                                            setDeviceRegion(device.id, regionId);
                                            this.open = false;
                                            this.search = '';
                                        }
                                    }" class="relative">
                                        <!-- Selected Region Display -->
                                        <button
                                            @click="open = !open"
                                            @click.away="open = false"
                                            type="button"
                                            class="w-full flex items-center justify-between text-sm py-2 px-3 rounded-md border border-gray-300 dark:border-gray-600 dark:bg-gray-600 dark:text-white shadow-sm focus:border-blue-500 focus:ring-blue-500 touch-manipulation">
                                            <span x-text="device.region_id ? (regions.find(r => r.id === device.region_id)?.name + ' (' + regions.find(r => r.id === device.region_id)?.country + ')') : '-- No VPN --'"></span>
                                            <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                            </svg>
                                        </button>

                                        <!-- Dropdown -->
                                        <div x-show="open" class="absolute z-10 mt-1 w-full bg-white dark:bg-gray-700 rounded-md shadow-lg max-h-60 overflow-y-auto">
                                            <!-- Search Box -->
                                            <div class="sticky top-0 p-2 bg-white dark:bg-gray-700 border-b border-gray-200 dark:border-gray-600">
                                                <input
                                                    x-model="search"
                                                    type="text"
                                                    placeholder="Search country or city..."
                                                    class="w-full text-sm py-1 px-2 rounded border border-gray-300 dark:border-gray-600 dark:bg-gray-600 dark:text-white focus:border-blue-500 focus:ring-blue-500">
                                            </div>

                                            <!-- No VPN Option -->
                                            <button
                                                @click="selectRegion('')"
                                                class="w-full text-left text-sm py-2 px-3 hover:bg-gray-100 dark:hover:bg-gray-600"
                                                :class="!device.region_id ? 'bg-blue-50 dark:bg-blue-900' : ''">
                                                -- No VPN --
                                            </button>

                                            <!-- Region List -->
                                            <template x-for="region in filteredRegions" :key="region.id">
                                                <button
                                                    @click="selectRegion(region.id)"
                                                    class="w-full text-left text-sm py-2 px-3 hover:bg-gray-100 dark:hover:bg-gray-600"
                                                    :class="device.region_id === region.id ? 'bg-blue-50 dark:bg-blue-900' : ''">
                                                    <span x-text="`${region.name} (${region.country})`"></span>
                                                </button>
                                            </template>

                                            <!-- No Results -->
                                            <div x-show="filteredRegions.length === 0" class="text-sm py-2 px-3 text-gray-500 dark:text-gray-400">
                                                No regions found
                                            </div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Status and Toggle Button -->
                                <div class="flex items-center justify-between">
                                    <div x-show="device.region_id" class="text-xs" :class="device.routing_enabled ? 'text-green-600 dark:text-green-400' : 'text-gray-500 dark:text-gray-400'">
                                        <span x-text="device.routing_enabled ? '✓ Routing enabled' : '⏳ Connecting...'"></span>
                                        <span x-show="device.auto_managed" class="ml-1 text-gray-500 dark:text-gray-400">(Set exit node in app)</span>
                                    </div>

                                    <!-- Play/Pause Toggle Button -->
                                    <button
                                        x-show="device.region_id"
                                        @click="toggleDeviceRouting(device.id)"
                                        :disabled="!device.region_id"
                                        class="flex items-center justify-center w-8 h-8 rounded-full transition-colors"
                                        :class="device.routing_enabled ? 'bg-green-100 text-green-700 hover:bg-green-200 dark:bg-green-900 dark:text-green-300 dark:hover:bg-green-800' : 'bg-gray-100 text-gray-700 hover:bg-gray-200 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600'"
                                        :title="device.routing_enabled ? 'Pause routing' : 'Start routing'">
                                        <!-- Play Icon (when paused) -->
                                        <svg x-show="!device.routing_enabled" class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
                                            <path d="M8 5v14l11-7z"/>
                                        </svg>
                                        <!-- Pause Icon (when playing) -->
                                        <svg x-show="device.routing_enabled" class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
                                            <path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>
                                        </svg>
                                    </button>
                                </div>
                            </div>
                        </div>
                    </template>
                    <div x-show="devices.length === 0" class="text-center py-8 text-gray-500 dark:text-gray-400 text-sm">
                        No devices found
                    </div>
                </div>

                <!-- Desktop Table Layout -->
                <div class="hidden md:block overflow-visible">
                    <table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                        <thead class="bg-gray-50 dark:bg-gray-700">
                            <tr>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Device</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">IP Address</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">OS</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Status</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">VPN Region</th>
                            </tr>
                        </thead>
                        <template x-for="device in devices" :key="device.id">
                            <tbody class="bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">
                                <tr class="hover:bg-gray-50 dark:hover:bg-gray-700">
                                    <td class="px-6 py-4 whitespace-nowrap">
                                        <div class="text-sm font-medium text-gray-900 dark:text-white" x-text="device.hostname"></div>
                                    </td>
                                    <td class="px-6 py-4 whitespace-nowrap">
                                        <div class="text-sm text-gray-600 dark:text-gray-400" x-text="device.ip_addresses.join(', ')"></div>
                                    </td>
                                    <td class="px-6 py-4 whitespace-nowrap">
                                        <div class="text-sm text-gray-600 dark:text-gray-400" x-text="device.os || 'Unknown'"></div>
                                    </td>
                                    <td class="px-6 py-4 whitespace-nowrap">
                                        <span :class="device.online ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200' : 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300'" class="px-2 py-1 text-xs rounded-full" x-text="device.online ? 'Online' : 'Offline'"></span>
                                    </td>
                                    <td class="px-6 py-4">
                                        <div class="flex items-center space-x-2">
                                            <!-- Searchable Dropdown -->
                                            <div x-data="{
                                                open: false,
                                                search: '',
                                                get filteredRegions() {
                                                    if (!this.search) return regions;
                                                    const searchLower = this.search.toLowerCase();
                                                    return regions.filter(r =>
                                                        r.name.toLowerCase().includes(searchLower) ||
                                                        r.country.toLowerCase().includes(searchLower)
                                                    );
                                                },
                                                selectRegion(regionId) {
                                                    setDeviceRegion(device.id, regionId);
                                                    this.open = false;
                                                    this.search = '';
                                                }
                                            }" class="relative flex-1">
                                                <!-- Selected Region Display -->
                                                <button
                                                    @click="open = !open"
                                                    @click.away="open = false"
                                                    type="button"
                                                    class="w-full flex items-center justify-between text-sm py-2 px-3 rounded-md border border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white shadow-sm focus:border-blue-500 focus:ring-blue-500 min-w-[200px]">
                                                    <span x-text="device.region_id ? (regions.find(r => r.id === device.region_id)?.name + ' (' + regions.find(r => r.id === device.region_id)?.country + ')') : '-- No VPN --'"></span>
                                                    <svg class="w-4 h-4 ml-2 flex-shrink-0" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                                    </svg>
                                                </button>

                                                <!-- Dropdown -->
                                                <div x-show="open" class="absolute z-10 mt-1 w-full bg-white dark:bg-gray-700 rounded-md shadow-lg max-h-60 overflow-y-auto">
                                                    <!-- Search Box -->
                                                    <div class="sticky top-0 p-2 bg-white dark:bg-gray-700 border-b border-gray-200 dark:border-gray-600">
                                                        <input
                                                            x-model="search"
                                                            type="text"
                                                            placeholder="Search country or city..."
                                                            class="w-full text-sm py-1 px-2 rounded border border-gray-300 dark:border-gray-600 dark:bg-gray-600 dark:text-white focus:border-blue-500 focus:ring-blue-500">
                                                    </div>

                                                    <!-- No VPN Option -->
                                                    <button
                                                        @click="selectRegion('')"
                                                        class="w-full text-left text-sm py-2 px-3 hover:bg-gray-100 dark:hover:bg-gray-600"
                                                        :class="!device.region_id ? 'bg-blue-50 dark:bg-blue-900' : ''">
                                                        -- No VPN --
                                                    </button>

                                                    <!-- Region List -->
                                                    <template x-for="region in filteredRegions" :key="region.id">
                                                        <button
                                                            @click="selectRegion(region.id)"
                                                            class="w-full text-left text-sm py-2 px-3 hover:bg-gray-100 dark:hover:bg-gray-600"
                                                            :class="device.region_id === region.id ? 'bg-blue-50 dark:bg-blue-900' : ''">
                                                            <span x-text="`${region.name} (${region.country})`"></span>
                                                        </button>
                                                    </template>

                                                    <!-- No Results -->
                                                    <div x-show="filteredRegions.length === 0" class="text-sm py-2 px-3 text-gray-500 dark:text-gray-400">
                                                        No regions found
                                                    </div>
                                                </div>
                                            </div>

                                            <!-- Play/Pause Toggle Button -->
                                            <button
                                                x-show="device.region_id"
                                                @click="toggleDeviceRouting(device.id)"
                                                :disabled="!device.region_id"
                                                class="flex items-center justify-center w-10 h-10 rounded-full transition-colors flex-shrink-0"
                                                :class="device.routing_enabled ? 'bg-green-100 text-green-700 hover:bg-green-200 dark:bg-green-900 dark:text-green-300 dark:hover:bg-green-800' : 'bg-gray-100 text-gray-700 hover:bg-gray-200 dark:bg-gray-700 dark:text-gray-300 dark:hover:bg-gray-600'"
                                                :title="device.routing_enabled ? 'Pause routing' : 'Start routing'">
                                                <!-- Play Icon (when paused) -->
                                                <svg x-show="!device.routing_enabled" class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                                                    <path d="M8 5v14l11-7z"/>
                                                </svg>
                                                <!-- Pause Icon (when playing) -->
                                                <svg x-show="device.routing_enabled" class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                                                    <path d="M6 4h4v16H6V4zm8 0h4v16h-4V4z"/>
                                                </svg>
                                            </button>
                                        </div>

                                        <!-- Status -->
                                        <div x-show="device.region_id" class="mt-2 text-xs" :class="device.routing_enabled ? 'text-green-600 dark:text-green-400' : 'text-gray-500 dark:text-gray-400'">
                                            <span x-text="device.routing_enabled ? '✓ Routing enabled' : '⏳ Connecting...'"></span>
                                            <span x-show="device.auto_managed" class="ml-1 text-gray-500 dark:text-gray-400">(Set exit node in Tailscale app)</span>
                                        </div>
                                    </td>
                                </tr>
                            </tbody>
                        </template>
                    </table>
                    <div x-show="devices.length === 0" class="text-center py-4 text-gray-500 dark:text-gray-400">
                        No devices found
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // Store charts outside Alpine.js reactivity to prevent proxy conflicts
        const globalCharts = {};
        const globalTransferHistory = {};

        function app() {
            return {
                loading: false,
                piaStatus: { connected: false, region_name: null, ip_address: null },
                vpnStatus: { active_count: 0, connections: [] },
                tailscaleStatus: { running: false, exit_node_enabled: false, hostname: null },
                systemHealth: { healthy: false, messages: [] },
                regions: [],
                selectedRegion: '',
                devices: [],
                pollInterval: null,
                websocket: null,
                wsReconnectTimeout: null,
                networkGraph: null,

                async init() {
                    await this.loadRegions();
                    await this.refreshStatus();

                    // Initialize network graph
                    this.initNetworkGraph();

                    // Connect to WebSocket for real-time VPN status updates
                    this.connectWebSocket();

                    // Poll other status (Tailscale, health, devices) every 5 seconds
                    this.pollInterval = setInterval(() => {
                        this.loadTailscaleStatus();
                        this.loadSystemHealth();
                        this.loadDevices();
                    }, 5000);
                },

                connectWebSocket() {
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}/api/status/ws/vpn-status`;

                    console.log('Connecting to WebSocket:', wsUrl);
                    this.websocket = new WebSocket(wsUrl);

                    this.websocket.onopen = () => {
                        console.log('WebSocket connected for real-time VPN status');
                    };

                    this.websocket.onmessage = (event) => {
                        try {
                            const data = JSON.parse(event.data);

                            // Update VPN status with real-time data
                            this.vpnStatus = {
                                active_count: data.active_count,
                                connections: data.connections
                            };

                            // Update visualizations
                            this.$nextTick(() => {
                                this.updateNetworkGraph();
                                this.updateCharts();
                            });
                        } catch (error) {
                            console.error('Failed to parse WebSocket message:', error);
                        }
                    };

                    this.websocket.onerror = (error) => {
                        console.error('WebSocket error:', error);
                    };

                    this.websocket.onclose = () => {
                        console.log('WebSocket disconnected, reconnecting in 3 seconds...');
                        // Reconnect after 3 seconds
                        this.wsReconnectTimeout = setTimeout(() => this.connectWebSocket(), 3000);
                    };
                },

                disconnectWebSocket() {
                    if (this.wsReconnectTimeout) {
                        clearTimeout(this.wsReconnectTimeout);
                        this.wsReconnectTimeout = null;
                    }
                    if (this.websocket) {
                        this.websocket.close();
                        this.websocket = null;
                    }
                },

                async loadRegions() {
                    try {
                        const response = await fetch('/api/settings/regions');
                        const data = await response.json();
                        this.regions = data.regions;
                    } catch (error) {
                        console.error('Failed to load regions:', error);
                    }
                },

                async refreshStatus() {
                    // Initial load - WebSocket will handle VPN status updates after this
                    await Promise.all([
                        this.loadVPNStatus(),
                        this.loadTailscaleStatus(),
                        this.loadSystemHealth(),
                        this.loadDevices()
                    ]);

                    // Update visualizations after status is loaded
                    this.$nextTick(() => {
                        this.updateNetworkGraph();
                        this.updateCharts();
                    });
                },

                destroy() {
                    // Cleanup when page is unloaded
                    this.disconnectWebSocket();
                    if (this.pollInterval) {
                        clearInterval(this.pollInterval);
                    }
                },

                async loadVPNStatus() {
                    try {
                        const response = await fetch('/api/status/vpn');
                        this.vpnStatus = await response.json();
                    } catch (error) {
                        console.error('Failed to load VPN status:', error);
                        this.vpnStatus = {
                            active_count: 0,
                            connections: []
                        };
                    }
                },

                async loadTailscaleStatus() {
                    try {
                        const response = await fetch('/api/status/tailscale');
                        this.tailscaleStatus = await response.json();
                    } catch (error) {
                        console.error('Failed to load Tailscale status:', error);
                    }
                },

                async loadSystemHealth() {
                    try {
                        const response = await fetch('/api/status/health');
                        this.systemHealth = await response.json();
                    } catch (error) {
                        console.error('Failed to load system health:', error);
                    }
                },

                async loadDevices() {
                    try {
                        const response = await fetch('/api/devices');
                        const data = await response.json();
                        this.devices = data.devices;
                    } catch (error) {
                        console.error('Failed to load devices:', error);
                    }
                },

                async setDeviceRegion(deviceId, regionId) {
                    try {
                        const response = await fetch(`/api/devices/${deviceId}/region`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ region_id: regionId || null })
                        });

                        if (!response.ok) {
                            const error = await response.json();
                            alert('Failed to set device region: ' + error.detail);
                            await this.loadDevices();
                        } else {
                            const data = await response.json();
                            await this.loadDevices();
                            await this.loadVPNStatus();
                            if (data.message) {
                                console.log('✓ ' + data.message);
                            }
                        }
                    } catch (error) {
                        alert('Failed to set device region: ' + error.message);
                        await this.loadDevices();
                    }
                },

                async toggleDeviceRouting(deviceId) {
                    try {
                        const response = await fetch(`/api/devices/${deviceId}/toggle`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({})
                        });

                        if (!response.ok) {
                            const error = await response.json();
                            alert('Failed to toggle device routing: ' + error.detail);
                            await this.loadDevices();
                        } else {
                            const data = await response.json();
                            await this.loadDevices();
                            await this.loadVPNStatus();
                            if (data.message) {
                                console.log('✓ ' + data.message);
                            }
                        }
                    } catch (error) {
                        alert('Failed to toggle device routing: ' + error.message);
                        await this.loadDevices();
                    }
                },

                initNetworkGraph() {
                    // Prevent duplicate initialization
                    if (this.networkGraph) return;

                    const container = document.getElementById('network-graph');
                    if (!container) return;

                    const width = container.clientWidth;
                    const height = 400;

                    // Clear any existing SVG first
                    d3.select('#network-graph').selectAll('svg').remove();

                    // Create SVG
                    const svg = d3.select('#network-graph')
                        .append('svg')
                        .attr('width', width)
                        .attr('height', height)
                        .attr('viewBox', [0, 0, width, height]);

                    // Add arrow marker
                    svg.append('defs').append('marker')
                        .attr('id', 'arrowhead')
                        .attr('viewBox', '-0 -5 10 10')
                        .attr('refX', 20)
                        .attr('refY', 0)
                        .attr('orient', 'auto')
                        .attr('markerWidth', 8)
                        .attr('markerHeight', 8)
                        .append('svg:path')
                        .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
                        .attr('fill', '#3b82f6');

                    // Create groups for links and nodes
                    const linkGroup = svg.append('g').attr('class', 'links');
                    const nodeGroup = svg.append('g').attr('class', 'nodes');

                    this.networkGraph = { svg, linkGroup, nodeGroup, width, height };
                },

                updateNetworkGraph() {
                    if (!this.networkGraph) return;

                    const { svg, linkGroup, nodeGroup, width, height } = this.networkGraph;

                    // Build graph data with FIXED positions
                    const nodes = [];
                    const links = [];
                    const centerX = width / 2;
                    const centerY = height / 2;
                    const meshRadius = 140;

                    // Position PIA exit nodes ONLY on left and right sides
                    const piaCount = this.vpnStatus.connections.length;
                    const piaNodes = {};
                    const leftPiaNodes = [];
                    const rightPiaNodes = [];

                    this.vpnStatus.connections.forEach((conn, idx) => {
                        const nodeId = `pia-${conn.region_id}`;

                        // Alternate between left and right sides
                        const isLeft = idx % 2 === 0;
                        const side = isLeft ? leftPiaNodes : rightPiaNodes;

                        const piaNode = {
                            id: nodeId,
                            label: conn.region_name,
                            type: 'pia',
                            region_id: conn.region_id,
                            isLeft: isLeft,
                            sideIndex: side.length
                        };

                        side.push(piaNode);
                        nodes.push(piaNode);
                        piaNodes[conn.region_id] = piaNode;
                    });

                    // Position left PIA nodes
                    leftPiaNodes.forEach((node, idx) => {
                        node.x = 80;
                        node.y = centerY + (idx - (leftPiaNodes.length - 1) / 2) * 100;
                    });

                    // Position right PIA nodes
                    rightPiaNodes.forEach((node, idx) => {
                        node.x = width - 80;
                        node.y = centerY + (idx - (rightPiaNodes.length - 1) / 2) * 100;
                    });

                    // Order devices intelligently: group by exit node side to minimize crossings
                    const leftSideDevices = [];
                    const rightSideDevices = [];
                    const unroutedDevices = [];

                    this.devices.forEach(device => {
                        if (device.region_id && piaNodes[device.region_id]) {
                            const piaNode = piaNodes[device.region_id];
                            if (piaNode.isLeft) {
                                leftSideDevices.push(device);
                            } else {
                                rightSideDevices.push(device);
                            }
                        } else {
                            unroutedDevices.push(device);
                        }
                    });

                    // Create ordered device list: left-exit, unrouted, right-exit
                    // This ordering minimizes crossings while maintaining ring
                    const orderedDevices = [
                        ...leftSideDevices,
                        ...unroutedDevices,
                        ...rightSideDevices
                    ];

                    // Position ALL devices evenly in a RING around full 360°
                    const deviceCount = orderedDevices.length;
                    orderedDevices.forEach((device, idx) => {
                        // Distribute evenly around full circle
                        const angle = (idx / deviceCount) * 2 * Math.PI - Math.PI / 2; // Start at top

                        nodes.push({
                            id: `device-${device.id}`,
                            label: device.hostname,
                            type: 'device',
                            online: device.online,
                            region_id: device.region_id,
                            x: centerX + meshRadius * Math.cos(angle),
                            y: centerY + meshRadius * Math.sin(angle)
                        });
                    });

                    // Add exit connections FIRST (so they render behind mesh)
                    const deviceNodes = nodes.filter(n => n.type === 'device');
                    deviceNodes.forEach(deviceNode => {
                        if (deviceNode.region_id) {
                            const piaNode = piaNodes[deviceNode.region_id];
                            if (piaNode) {
                                links.push({
                                    source: deviceNode,
                                    target: piaNode,
                                    type: 'exit'
                                });
                            }
                        }
                    });

                    // Create mesh connections between all devices (render on top)
                    for (let i = 0; i < deviceNodes.length; i++) {
                        for (let j = i + 1; j < deviceNodes.length; j++) {
                            links.push({
                                source: deviceNodes[i],
                                target: deviceNodes[j],
                                type: 'mesh'
                            });
                        }
                    }

                    // Update links
                    const link = linkGroup.selectAll('line')
                        .data(links, d => `${d.source.id}-${d.target.id}`);

                    link.exit().remove();

                    const linkEnter = link.enter()
                        .append('line')
                        .attr('stroke', d => d.type === 'mesh' ? '#6b7280' : '#60a5fa')  // mesh: gray, exit: lighter blue
                        .attr('stroke-width', d => d.type === 'mesh' ? 4 : 2)  // mesh: thicker (4px), exit: thin (2px)
                        .attr('stroke-opacity', d => d.type === 'mesh' ? 0.9 : 0.3);  // mesh: solid, exit: light

                    linkEnter.merge(link)
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y);

                    // Update nodes
                    const node = nodeGroup.selectAll('g')
                        .data(nodes, d => d.id);

                    node.exit().remove();

                    const nodeEnter = node.enter()
                        .append('g')
                        .attr('class', 'network-node');

                    nodeEnter.append('circle')
                        .attr('r', d => d.type === 'pia' ? 25 : 20);

                    nodeEnter.append('text')
                        .attr('dy', 35)
                        .attr('text-anchor', 'middle')
                        .attr('class', 'text-gray-900 dark:text-white')
                        .style('font-size', '11px');

                    const allNodes = nodeEnter.merge(node);

                    allNodes
                        .attr('transform', d => `translate(${d.x},${d.y})`);

                    allNodes.select('circle')
                        .attr('fill', d => {
                            if (d.type === 'pia') return '#22c55e';
                            return d.online ? '#3b82f6' : '#6b7280';
                        })
                        .attr('stroke', '#fff')
                        .attr('stroke-width', 2);

                    allNodes.select('text')
                        .text(d => d.label);
                },

                updateCharts() {
                    // Track which interfaces are still active
                    const activeInterfaces = new Set();

                    // Create/update charts for each VPN connection
                    this.vpnStatus.connections.forEach(conn => {
                        activeInterfaces.add(conn.interface);

                        const chartId = 'chart-' + conn.interface;
                        const chartDiv = document.getElementById(chartId);

                        if (!chartDiv) return;

                        // Check if existing chart is still valid
                        if (globalCharts[conn.interface]) {
                            const chart = globalCharts[conn.interface];
                            if (!chart || !chart.root || !chart.root.isConnected) {
                                // Chart was removed from DOM, destroy it
                                if (chart && chart.destroy) chart.destroy();
                                delete globalCharts[conn.interface];
                            }
                        }

                        // Initialize transfer history for this connection
                        if (!globalTransferHistory[conn.interface]) {
                            globalTransferHistory[conn.interface] = {
                                timestamps: [],  // Unix timestamps in seconds
                                rx: [],
                                tx: [],
                                rawRx: [],  // Store raw rates for moving average
                                rawTx: [],  // Store raw rates for moving average
                                prevRx: conn.transfer_rx_bytes || 0,
                                prevTx: conn.transfer_tx_bytes || 0,
                                prevTime: Date.now()
                            };
                        }

                        const history = globalTransferHistory[conn.interface];
                        const now = Date.now();
                        const timeDelta = (now - history.prevTime) / 1000; // seconds

                        // Calculate rates (bytes per second)
                        const rxBytes = conn.transfer_rx_bytes || 0;
                        const txBytes = conn.transfer_tx_bytes || 0;

                        // Calculate rates (validate time delta to prevent magnitude errors)
                        let rawRxRate = 0;
                        let rawTxRate = 0;

                        if (timeDelta > 0.1 && timeDelta < 30) { // Reasonable time window (0.1s to 30s)
                            const rxDelta = rxBytes - history.prevRx;
                            const txDelta = txBytes - history.prevTx;

                            // Debug logging for Singapore
                            if (conn.interface === 'pia-sg') {
                                console.log(`[${conn.interface}] RX: ${rxBytes} (prev: ${history.prevRx}, delta: ${rxDelta}), Time: ${timeDelta.toFixed(2)}s`);
                            }

                            // Calculate instantaneous rate
                            rawRxRate = rxDelta / timeDelta;
                            rawTxRate = txDelta / timeDelta;

                            // More debug logging
                            if (conn.interface === 'pia-sg') {
                                console.log(`[${conn.interface}] Calculated rate: ${(rawRxRate / 1024 / 1024).toFixed(2)} MB/s`);
                            }

                            // Sanity check: if rate exceeds 1 Gbps, something is wrong
                            const maxRate = 1024 * 1024 * 1024 / 8; // 1 Gbps in bytes/sec
                            if (rawRxRate > maxRate) {
                                console.warn(`Rate ${rawRxRate} exceeds 1 Gbps limit for ${conn.interface}`);
                                rawRxRate = 0;
                            }
                            if (rawTxRate > maxRate) {
                                console.warn(`Rate ${rawTxRate} exceeds 1 Gbps limit for ${conn.interface}`);
                                rawTxRate = 0;
                            }
                        } else {
                            console.warn(`Invalid timeDelta ${timeDelta} for ${conn.interface}, skipping rate calculation`);
                        }

                        history.prevRx = rxBytes;
                        history.prevTx = txBytes;
                        history.prevTime = now;

                        // Apply noise floor: rates below 10 KB/s are treated as zero
                        const noiseFloor = 10 * 1024; // 10 KB/s
                        const cleanRxRate = rawRxRate > noiseFloor ? rawRxRate : 0;
                        const cleanTxRate = rawTxRate > noiseFloor ? rawTxRate : 0;

                        // Store cleaned rates
                        history.rawRx.push(Math.max(0, cleanRxRate));
                        history.rawTx.push(Math.max(0, cleanTxRate));

                        // Keep last 30 raw samples for moving average calculation
                        if (history.rawRx.length > 30) {
                            history.rawRx.shift();
                            history.rawTx.shift();
                        }

                        // Calculate simple moving average over last 10 samples for smooth but responsive lines
                        const windowSize = Math.min(10, history.rawRx.length);
                        const recentRx = history.rawRx.slice(-windowSize);
                        const recentTx = history.rawTx.slice(-windowSize);

                        const smoothedRx = recentRx.reduce((a, b) => a + b, 0) / windowSize;
                        const smoothedTx = recentTx.reduce((a, b) => a + b, 0) / windowSize;

                        // Add to history (keep last 120 data points = 2 minutes at 1s polling)
                        // uPlot requires Unix timestamps in seconds
                        history.timestamps.push(Math.floor(now / 1000));
                        history.rx.push(smoothedRx);
                        history.tx.push(smoothedTx);

                        if (history.timestamps.length > 120) {
                            history.timestamps.shift();
                            history.rx.shift();
                            history.tx.shift();
                        }

                        // Create or update chart
                        if (!globalCharts[conn.interface]) {
                            // uPlot options
                            const isDark = document.documentElement.classList.contains('dark');
                            // Responsive chart sizing
                            const chartWidth = Math.max(chartDiv.clientWidth, 280);
                            const chartHeight = window.innerWidth < 768 ? 120 : 150;
                            const opts = {
                                width: chartWidth,
                                height: chartHeight,
                                padding: [10, 10, 10, 0],  // top, right, bottom, left - no left padding (handled by axis size)
                                series: [
                                    {
                                        label: 'Time'
                                    },
                                    {
                                        label: 'Download',
                                        stroke: 'rgb(34, 197, 94)',
                                        fill: 'rgba(34, 197, 94, 0.1)',
                                        width: 2,
                                        value: (self, rawValue) => rawValue == null ? '-' : formatBytes(rawValue) + '/s'
                                    },
                                    {
                                        label: 'Upload',
                                        stroke: 'rgb(59, 130, 246)',
                                        fill: 'rgba(59, 130, 246, 0.1)',
                                        width: 2,
                                        value: (self, rawValue) => rawValue == null ? '-' : formatBytes(rawValue) + '/s'
                                    }
                                ],
                                axes: [
                                    {
                                        // X-axis (time)
                                        show: false
                                    },
                                    {
                                        // Y-axis (bytes/s)
                                        stroke: isDark ? '#9ca3af' : '#6b7280',
                                        grid: {
                                            stroke: isDark ? '#374151' : '#e5e7eb',
                                            width: 1
                                        },
                                        values: (self, ticks) => ticks.map(v => formatBytes(v) + '/s'),
                                        size: 70  // Increased from 50 to 70 for full label visibility
                                    }
                                ],
                                legend: {
                                    show: false  // Hide legend, we show current rates in the card UI
                                },
                                cursor: {
                                    drag: {
                                        x: false,
                                        y: false
                                    }
                                }
                            };

                            // uPlot data format: [[timestamps], [rx_values], [tx_values]]
                            const data = [
                                [...history.timestamps],
                                [...history.rx],
                                [...history.tx]
                            ];

                            globalCharts[conn.interface] = new uPlot(opts, data, chartDiv);
                        } else {
                            // Update existing chart
                            const chart = globalCharts[conn.interface];
                            if (chart && chart.root && chart.root.isConnected) {
                                try {
                                    // uPlot data format: [[timestamps], [rx_values], [tx_values]]
                                    const data = [
                                        [...history.timestamps],
                                        [...history.rx],
                                        [...history.tx]
                                    ];
                                    chart.setData(data);
                                } catch (e) {
                                    console.error('Chart update failed:', e);
                                    // Destroy broken chart
                                    chart.destroy();
                                    delete globalCharts[conn.interface];
                                }
                            }
                        }
                    });

                    // Clean up charts for interfaces that no longer exist
                    Object.keys(globalCharts).forEach(interface_name => {
                        if (!activeInterfaces.has(interface_name)) {
                            globalCharts[interface_name].destroy();
                            delete globalCharts[interface_name];
                        }
                    });
                },

                getCurrentRate(interface_name, direction) {
                    const history = globalTransferHistory[interface_name];
                    if (!history || !history[direction] || history[direction].length === 0) {
                        return 0;
                    }
                    // Return the latest rate
                    return history[direction][history[direction].length - 1];
                },

                formatRate(bytesPerSecond) {
                    return formatBytes(bytesPerSecond) + '/s';
                }
            }
        }

        // Utility function for formatting bytes
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
    </script>
</body>
</html>
