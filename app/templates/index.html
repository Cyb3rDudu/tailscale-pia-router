<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tailscale PIA Router</title>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script>
        tailwind.config = {
            darkMode: 'media'
        }
    </script>
</head>
<body class="bg-gray-100 dark:bg-gray-900" x-data="app()" x-init="init()">
    <div class="min-h-screen">
        <!-- Header -->
        <header class="bg-white dark:bg-gray-800 shadow">
            <div class="max-w-7xl mx-auto px-4 py-6 sm:px-6 lg:px-8">
                <div class="flex justify-between items-center">
                    <h1 class="text-3xl font-bold text-gray-900 dark:text-white">Tailscale PIA Router</h1>
                    <div class="flex items-center space-x-6">
                        <!-- Compact Status Indicators -->
                        <div class="flex items-center space-x-2">
                            <div :class="vpnStatus.active_count > 0 ? 'bg-green-500' : 'bg-gray-500'" class="w-2.5 h-2.5 rounded-full"></div>
                            <span class="text-sm text-gray-700 dark:text-gray-300">
                                <span x-text="vpnStatus.active_count"></span> VPN
                            </span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <div :class="tailscaleStatus.running ? 'bg-green-500' : 'bg-red-500'" class="w-2.5 h-2.5 rounded-full"></div>
                            <span class="text-sm text-gray-700 dark:text-gray-300">Tailscale</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <div :class="systemHealth.healthy ? 'bg-green-500' : 'bg-yellow-500'" class="w-2.5 h-2.5 rounded-full"></div>
                            <span class="text-sm text-gray-700 dark:text-gray-300">System</span>
                        </div>
                        <a href="/settings" class="text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300 text-sm">Settings</a>
                    </div>
                </div>
            </div>
        </header>

        <main class="max-w-7xl mx-auto px-4 py-6 sm:px-6 lg:px-8">
            <!-- Network Topology Visualization -->
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-6">
                <h2 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Network Topology</h2>
                <div class="flex items-center justify-center py-8">
                    <!-- Tailscale Network (Left) -->
                    <div class="flex flex-col items-center space-y-3">
                        <div class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Tailscale Network</div>
                        <template x-for="device in devices.filter(d => d.region_id)" :key="device.id">
                            <div class="flex items-center space-x-2 bg-blue-50 dark:bg-blue-900/20 px-4 py-2 rounded-lg">
                                <div :class="device.online ? 'bg-green-500' : 'bg-gray-500'" class="w-2 h-2 rounded-full"></div>
                                <span class="text-sm text-gray-900 dark:text-white" x-text="device.hostname"></span>
                                <span class="text-xs text-gray-500 dark:text-gray-400" x-text="device.ip_addresses[0]"></span>
                            </div>
                        </template>
                        <div x-show="devices.filter(d => d.region_id).length === 0" class="text-sm text-gray-500 dark:text-gray-400 italic">
                            No devices routing through VPN
                        </div>
                    </div>

                    <!-- Arrow / Connection -->
                    <div class="mx-12 flex flex-col items-center">
                        <svg class="w-24 h-12" viewBox="0 0 100 50" xmlns="http://www.w3.org/2000/svg">
                            <defs>
                                <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                                    <polygon points="0 0, 10 3, 0 6" class="fill-blue-500" />
                                </marker>
                            </defs>
                            <line x1="10" y1="25" x2="90" y2="25" class="stroke-blue-500 stroke-2" marker-end="url(#arrowhead)" />
                        </svg>
                        <span class="text-xs text-gray-500 dark:text-gray-400 mt-1">Exit Node</span>
                    </div>

                    <!-- PIA Exit Nodes (Right) -->
                    <div class="flex flex-col items-center space-y-3">
                        <div class="text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">PIA Exit Nodes</div>
                        <template x-for="conn in vpnStatus.connections" :key="conn.region_id">
                            <div class="flex items-center space-x-2 bg-green-50 dark:bg-green-900/20 px-4 py-2 rounded-lg">
                                <div class="bg-green-500 w-2 h-2 rounded-full"></div>
                                <span class="text-sm font-medium text-gray-900 dark:text-white" x-text="conn.region_name"></span>
                                <span class="text-xs text-gray-500 dark:text-gray-400" x-text="conn.interface"></span>
                            </div>
                        </template>
                        <div x-show="vpnStatus.connections.length === 0" class="text-sm text-gray-500 dark:text-gray-400 italic">
                            No VPN connections
                        </div>
                    </div>
                </div>
            </div>

            <!-- VPN Connection Cards Grid -->
            <div x-show="vpnStatus.connections && vpnStatus.connections.length > 0">
                <h2 class="text-xl font-semibold text-gray-900 dark:text-white mb-4">VPN Connections</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-6">
                    <template x-for="conn in vpnStatus.connections" :key="conn.region_id">
                        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
                            <!-- Connection Header -->
                            <div class="flex items-center justify-between mb-4">
                                <div>
                                    <h3 class="text-lg font-semibold text-gray-900 dark:text-white" x-text="conn.region_name"></h3>
                                    <p class="text-xs text-gray-500 dark:text-gray-400" x-text="conn.interface"></p>
                                </div>
                                <div class="bg-green-500 w-3 h-3 rounded-full"></div>
                            </div>

                            <!-- Stats -->
                            <div class="space-y-2 mb-4">
                                <div class="flex justify-between text-sm">
                                    <span class="text-gray-600 dark:text-gray-400">Last Handshake</span>
                                    <span class="text-gray-900 dark:text-white font-medium" x-text="conn.last_handshake || 'N/A'"></span>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <span class="text-gray-600 dark:text-gray-400">↓ Received</span>
                                    <span class="text-gray-900 dark:text-white font-medium" x-text="conn.transfer_rx || '0 B'"></span>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <span class="text-gray-600 dark:text-gray-400">↑ Sent</span>
                                    <span class="text-gray-900 dark:text-white font-medium" x-text="conn.transfer_tx || '0 B'"></span>
                                </div>
                            </div>

                            <!-- Transfer Rate Chart -->
                            <div class="mt-4">
                                <canvas :id="'chart-' + conn.interface" class="w-full" style="height: 150px;"></canvas>
                            </div>

                            <!-- Devices using this connection -->
                            <div class="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
                                <div class="text-xs font-medium text-gray-700 dark:text-gray-300 mb-2">Devices</div>
                                <div class="space-y-1">
                                    <template x-for="device in devices.filter(d => d.region_id === conn.region_id)" :key="device.id">
                                        <div class="text-xs text-gray-600 dark:text-gray-400 flex items-center space-x-1">
                                            <div :class="device.online ? 'bg-green-500' : 'bg-gray-500'" class="w-1.5 h-1.5 rounded-full"></div>
                                            <span x-text="device.hostname"></span>
                                        </div>
                                    </template>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>
            </div>

            <!-- Device List -->
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
                <h2 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Tailscale Devices</h2>
                <div class="overflow-visible">
                    <table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                        <thead class="bg-gray-50 dark:bg-gray-700">
                            <tr>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Device</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">IP Address</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">OS</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Status</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">VPN Region</th>
                            </tr>
                        </thead>
                        <template x-for="device in devices" :key="device.id">
                            <tbody class="bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">
                                <tr class="hover:bg-gray-50 dark:hover:bg-gray-700">
                                    <td class="px-6 py-4 whitespace-nowrap">
                                        <div class="text-sm font-medium text-gray-900 dark:text-white" x-text="device.hostname"></div>
                                    </td>
                                    <td class="px-6 py-4 whitespace-nowrap">
                                        <div class="text-sm text-gray-600 dark:text-gray-400" x-text="device.ip_addresses.join(', ')"></div>
                                    </td>
                                    <td class="px-6 py-4 whitespace-nowrap">
                                        <div class="text-sm text-gray-600 dark:text-gray-400" x-text="device.os || 'Unknown'"></div>
                                    </td>
                                    <td class="px-6 py-4 whitespace-nowrap">
                                        <span :class="device.online ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200' : 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300'" class="px-2 py-1 text-xs rounded-full" x-text="device.online ? 'Online' : 'Offline'"></span>
                                    </td>
                                    <td class="px-6 py-4">
                                        <select
                                            @change="setDeviceRegion(device.id, $event.target.value)"
                                            class="text-sm rounded-md border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white shadow-sm focus:border-blue-500 focus:ring-blue-500">
                                            <option value="">-- No VPN --</option>
                                            <template x-for="region in regions" :key="region.id">
                                                <option :value="region.id" :selected="device.region_id === region.id" x-text="`${region.name} (${region.country})`"></option>
                                            </template>
                                        </select>
                                        <div x-show="device.region_id" class="mt-1 text-xs" :class="device.routing_enabled ? 'text-green-600 dark:text-green-400' : 'text-gray-500 dark:text-gray-400'">
                                            <span x-text="device.routing_enabled ? '✓ Routing enabled' : '⏳ Connecting...'"></span>
                                            <span x-show="device.auto_managed" class="ml-1 text-gray-500 dark:text-gray-400">(Set exit node in Tailscale app)</span>
                                        </div>
                                    </td>
                                </tr>
                            </tbody>
                        </template>
                    </table>
                    <div x-show="devices.length === 0" class="text-center py-4 text-gray-500 dark:text-gray-400">
                        No devices found
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        function app() {
            return {
                loading: false,
                piaStatus: { connected: false, region_name: null, ip_address: null },
                vpnStatus: { active_count: 0, connections: [] },
                tailscaleStatus: { running: false, exit_node_enabled: false, hostname: null },
                systemHealth: { healthy: false, messages: [] },
                regions: [],
                selectedRegion: '',
                devices: [],
                pollInterval: null,
                charts: {},
                transferHistory: {},

                async init() {
                    await this.loadRegions();
                    await this.refreshStatus();

                    // Poll status every 5 seconds
                    this.pollInterval = setInterval(() => this.refreshStatus(), 5000);
                },

                async loadRegions() {
                    try {
                        const response = await fetch('/api/settings/regions');
                        const data = await response.json();
                        this.regions = data.regions;
                    } catch (error) {
                        console.error('Failed to load regions:', error);
                    }
                },

                async refreshStatus() {
                    await Promise.all([
                        this.loadVPNStatus(),
                        this.loadTailscaleStatus(),
                        this.loadSystemHealth(),
                        this.loadDevices()
                    ]);

                    // Update charts after status is loaded
                    this.$nextTick(() => {
                        this.updateCharts();
                    });
                },

                async loadVPNStatus() {
                    try {
                        const response = await fetch('/api/status/vpn');
                        this.vpnStatus = await response.json();
                    } catch (error) {
                        console.error('Failed to load VPN status:', error);
                        this.vpnStatus = {
                            active_count: 0,
                            connections: []
                        };
                    }
                },

                async loadTailscaleStatus() {
                    try {
                        const response = await fetch('/api/status/tailscale');
                        this.tailscaleStatus = await response.json();
                    } catch (error) {
                        console.error('Failed to load Tailscale status:', error);
                    }
                },

                async loadSystemHealth() {
                    try {
                        const response = await fetch('/api/status/health');
                        this.systemHealth = await response.json();
                    } catch (error) {
                        console.error('Failed to load system health:', error);
                    }
                },

                async loadDevices() {
                    try {
                        const response = await fetch('/api/devices');
                        const data = await response.json();
                        this.devices = data.devices;
                    } catch (error) {
                        console.error('Failed to load devices:', error);
                    }
                },

                async setDeviceRegion(deviceId, regionId) {
                    try {
                        const response = await fetch(`/api/devices/${deviceId}/region`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ region_id: regionId || null })
                        });

                        if (!response.ok) {
                            const error = await response.json();
                            alert('Failed to set device region: ' + error.detail);
                            await this.loadDevices();
                        } else {
                            const data = await response.json();
                            await this.loadDevices();
                            await this.loadVPNStatus();
                            if (data.message) {
                                console.log('✓ ' + data.message);
                            }
                        }
                    } catch (error) {
                        alert('Failed to set device region: ' + error.message);
                        await this.loadDevices();
                    }
                },

                updateCharts() {
                    // Create/update charts for each VPN connection
                    this.vpnStatus.connections.forEach(conn => {
                        const chartId = 'chart-' + conn.interface;
                        const canvas = document.getElementById(chartId);

                        if (!canvas) return;

                        // Initialize transfer history for this connection
                        if (!this.transferHistory[conn.interface]) {
                            this.transferHistory[conn.interface] = {
                                timestamps: [],
                                rx: [],
                                tx: [],
                                prevRx: 0,
                                prevTx: 0
                            };
                        }

                        const history = this.transferHistory[conn.interface];
                        const now = new Date();

                        // Parse transfer values (e.g., "57.65 MiB received" -> bytes)
                        const rxBytes = this.parseTransferToBytes(conn.transfer_rx);
                        const txBytes = this.parseTransferToBytes(conn.transfer_tx);

                        // Calculate rates (bytes per 5 seconds = polling interval)
                        const rxRate = rxBytes - history.prevRx;
                        const txRate = txBytes - history.prevTx;

                        history.prevRx = rxBytes;
                        history.prevTx = txBytes;

                        // Add to history (keep last 20 data points = 100 seconds)
                        history.timestamps.push(now.toLocaleTimeString());
                        history.rx.push(rxRate > 0 ? rxRate / 5 : 0); // bytes per second
                        history.tx.push(txRate > 0 ? txRate / 5 : 0);

                        if (history.timestamps.length > 20) {
                            history.timestamps.shift();
                            history.rx.shift();
                            history.tx.shift();
                        }

                        // Create or update chart
                        if (!this.charts[conn.interface]) {
                            const ctx = canvas.getContext('2d');
                            this.charts[conn.interface] = new Chart(ctx, {
                                type: 'line',
                                data: {
                                    labels: history.timestamps,
                                    datasets: [
                                        {
                                            label: 'Download',
                                            data: history.rx,
                                            borderColor: 'rgb(34, 197, 94)',
                                            backgroundColor: 'rgba(34, 197, 94, 0.1)',
                                            tension: 0.4,
                                            fill: true
                                        },
                                        {
                                            label: 'Upload',
                                            data: history.tx,
                                            borderColor: 'rgb(59, 130, 246)',
                                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                            tension: 0.4,
                                            fill: true
                                        }
                                    ]
                                },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    interaction: {
                                        intersect: false,
                                        mode: 'index'
                                    },
                                    plugins: {
                                        legend: {
                                            display: true,
                                            position: 'bottom',
                                            labels: {
                                                color: document.documentElement.classList.contains('dark') ? '#9ca3af' : '#4b5563',
                                                boxWidth: 12,
                                                padding: 10,
                                                font: { size: 10 }
                                            }
                                        },
                                        tooltip: {
                                            callbacks: {
                                                label: function(context) {
                                                    return context.dataset.label + ': ' + formatBytes(context.parsed.y) + '/s';
                                                }
                                            }
                                        }
                                    },
                                    scales: {
                                        x: {
                                            display: false
                                        },
                                        y: {
                                            beginAtZero: true,
                                            ticks: {
                                                color: document.documentElement.classList.contains('dark') ? '#9ca3af' : '#6b7280',
                                                callback: function(value) {
                                                    return formatBytes(value) + '/s';
                                                },
                                                font: { size: 10 }
                                            },
                                            grid: {
                                                color: document.documentElement.classList.contains('dark') ? '#374151' : '#e5e7eb'
                                            }
                                        }
                                    }
                                }
                            });
                        } else {
                            // Update existing chart
                            const chart = this.charts[conn.interface];
                            chart.data.labels = history.timestamps;
                            chart.data.datasets[0].data = history.rx;
                            chart.data.datasets[1].data = history.tx;
                            chart.update('none'); // Update without animation for smoother updates
                        }
                    });
                },

                parseTransferToBytes(transferStr) {
                    if (!transferStr) return 0;

                    // Extract number and unit (e.g., "57.65 MiB received" -> ["57.65", "MiB"])
                    const match = transferStr.match(/([\d.]+)\s*([KMGT]i?B)/i);
                    if (!match) return 0;

                    const value = parseFloat(match[1]);
                    const unit = match[2].toUpperCase();

                    const multipliers = {
                        'B': 1,
                        'KB': 1000,
                        'KIB': 1024,
                        'MB': 1000 * 1000,
                        'MIB': 1024 * 1024,
                        'GB': 1000 * 1000 * 1000,
                        'GIB': 1024 * 1024 * 1024,
                        'TB': 1000 * 1000 * 1000 * 1000,
                        'TIB': 1024 * 1024 * 1024 * 1024
                    };

                    return value * (multipliers[unit] || 1);
                }
            }
        }

        // Utility function for formatting bytes
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
    </script>
</body>
</html>
