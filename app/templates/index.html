<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tailscale PIA Router</title>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script>
        tailwind.config = {
            darkMode: 'media'
        }
    </script>
    <style>
        .network-link {
            stroke: #3b82f6;
            stroke-width: 2px;
            marker-end: url(#arrowhead);
        }
        .network-node {
            cursor: pointer;
        }
        .network-node circle {
            stroke: #fff;
            stroke-width: 2px;
        }
        .network-node text {
            font-size: 12px;
            pointer-events: none;
            fill: #1f2937;
        }
        @media (prefers-color-scheme: dark) {
            .network-node text {
                fill: #f9fafb;
            }
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900" x-data="app()" x-init="init()">
    <div class="min-h-screen">
        <!-- Header -->
        <header class="bg-white dark:bg-gray-800 shadow">
            <div class="max-w-7xl mx-auto px-4 py-6 sm:px-6 lg:px-8">
                <div class="flex justify-between items-center">
                    <h1 class="text-3xl font-bold text-gray-900 dark:text-white">Tailscale PIA Router</h1>
                    <div class="flex items-center space-x-6">
                        <!-- Compact Status Indicators -->
                        <div class="flex items-center space-x-2">
                            <div :class="vpnStatus.active_count > 0 ? 'bg-green-500' : 'bg-gray-500'" class="w-2.5 h-2.5 rounded-full"></div>
                            <span class="text-sm text-gray-700 dark:text-gray-300">
                                <span x-text="vpnStatus.active_count"></span> VPN
                            </span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <div :class="tailscaleStatus.running ? 'bg-green-500' : 'bg-red-500'" class="w-2.5 h-2.5 rounded-full"></div>
                            <span class="text-sm text-gray-700 dark:text-gray-300">Tailscale</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <div :class="systemHealth.healthy ? 'bg-green-500' : 'bg-yellow-500'" class="w-2.5 h-2.5 rounded-full"></div>
                            <span class="text-sm text-gray-700 dark:text-gray-300">System</span>
                        </div>
                        <a href="/settings" class="text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300 text-sm">Settings</a>
                    </div>
                </div>
            </div>
        </header>

        <main class="max-w-7xl mx-auto px-4 py-6 sm:px-6 lg:px-8">
            <!-- VPN Connection Cards Grid -->
            <div x-show="vpnStatus.connections && vpnStatus.connections.length > 0">
                <h2 class="text-xl font-semibold text-gray-900 dark:text-white mb-4">VPN Connections</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-6">
                    <template x-for="conn in vpnStatus.connections" :key="conn.region_id">
                        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
                            <!-- Connection Header -->
                            <div class="flex items-center justify-between mb-4">
                                <div>
                                    <h3 class="text-lg font-semibold text-gray-900 dark:text-white" x-text="conn.region_name"></h3>
                                    <p class="text-xs text-gray-500 dark:text-gray-400" x-text="conn.interface"></p>
                                </div>
                                <div class="bg-green-500 w-3 h-3 rounded-full"></div>
                            </div>

                            <!-- Stats -->
                            <div class="space-y-2 mb-4">
                                <div class="flex justify-between text-sm">
                                    <span class="text-gray-600 dark:text-gray-400">Last Handshake</span>
                                    <span class="text-gray-900 dark:text-white font-medium" x-text="conn.last_handshake || 'N/A'"></span>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <span class="text-gray-600 dark:text-gray-400">Total ↓</span>
                                    <span class="text-gray-900 dark:text-white font-medium" x-text="conn.transfer_rx || '0 B'"></span>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <span class="text-gray-600 dark:text-gray-400">Total ↑</span>
                                    <span class="text-gray-900 dark:text-white font-medium" x-text="conn.transfer_tx || '0 B'"></span>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <span class="text-gray-600 dark:text-gray-400">Current ↓</span>
                                    <span class="text-green-600 dark:text-green-400 font-medium" x-text="formatRate(getCurrentRate(conn.interface, 'rx'))"></span>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <span class="text-gray-600 dark:text-gray-400">Current ↑</span>
                                    <span class="text-blue-600 dark:text-blue-400 font-medium" x-text="formatRate(getCurrentRate(conn.interface, 'tx'))"></span>
                                </div>
                            </div>

                            <!-- Throughput Chart -->
                            <div class="mt-4">
                                <div class="text-xs text-gray-500 dark:text-gray-400 mb-2">Throughput (last 2 minutes)</div>
                                <div style="height: 150px; position: relative;">
                                    <canvas :id="'chart-' + conn.interface" style="position: absolute; width: 100%; height: 100%;"></canvas>
                                </div>
                            </div>

                            <!-- Devices using this connection -->
                            <div class="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
                                <div class="text-xs font-medium text-gray-700 dark:text-gray-300 mb-2">Devices</div>
                                <div class="space-y-1">
                                    <template x-for="device in devices.filter(d => d.region_id === conn.region_id)" :key="device.id">
                                        <div class="text-xs text-gray-600 dark:text-gray-400 flex items-center space-x-1">
                                            <div :class="device.online ? 'bg-green-500' : 'bg-gray-500'" class="w-1.5 h-1.5 rounded-full"></div>
                                            <span x-text="device.hostname"></span>
                                        </div>
                                    </template>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>
            </div>

            <!-- Network Topology Mesh -->
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-6">
                <h2 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Network Topology</h2>
                <div id="network-graph" class="w-full" style="height: 400px; overflow: hidden;"></div>
            </div>

            <!-- Device List -->
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
                <h2 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Tailscale Devices</h2>
                <div class="overflow-visible">
                    <table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                        <thead class="bg-gray-50 dark:bg-gray-700">
                            <tr>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Device</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">IP Address</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">OS</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Status</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">VPN Region</th>
                            </tr>
                        </thead>
                        <template x-for="device in devices" :key="device.id">
                            <tbody class="bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">
                                <tr class="hover:bg-gray-50 dark:hover:bg-gray-700">
                                    <td class="px-6 py-4 whitespace-nowrap">
                                        <div class="text-sm font-medium text-gray-900 dark:text-white" x-text="device.hostname"></div>
                                    </td>
                                    <td class="px-6 py-4 whitespace-nowrap">
                                        <div class="text-sm text-gray-600 dark:text-gray-400" x-text="device.ip_addresses.join(', ')"></div>
                                    </td>
                                    <td class="px-6 py-4 whitespace-nowrap">
                                        <div class="text-sm text-gray-600 dark:text-gray-400" x-text="device.os || 'Unknown'"></div>
                                    </td>
                                    <td class="px-6 py-4 whitespace-nowrap">
                                        <span :class="device.online ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200' : 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300'" class="px-2 py-1 text-xs rounded-full" x-text="device.online ? 'Online' : 'Offline'"></span>
                                    </td>
                                    <td class="px-6 py-4">
                                        <select
                                            @change="setDeviceRegion(device.id, $event.target.value)"
                                            class="text-sm rounded-md border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white shadow-sm focus:border-blue-500 focus:ring-blue-500">
                                            <option value="">-- No VPN --</option>
                                            <template x-for="region in regions" :key="region.id">
                                                <option :value="region.id" :selected="device.region_id === region.id" x-text="`${region.name} (${region.country})`"></option>
                                            </template>
                                        </select>
                                        <div x-show="device.region_id" class="mt-1 text-xs" :class="device.routing_enabled ? 'text-green-600 dark:text-green-400' : 'text-gray-500 dark:text-gray-400'">
                                            <span x-text="device.routing_enabled ? '✓ Routing enabled' : '⏳ Connecting...'"></span>
                                            <span x-show="device.auto_managed" class="ml-1 text-gray-500 dark:text-gray-400">(Set exit node in Tailscale app)</span>
                                        </div>
                                    </td>
                                </tr>
                            </tbody>
                        </template>
                    </table>
                    <div x-show="devices.length === 0" class="text-center py-4 text-gray-500 dark:text-gray-400">
                        No devices found
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // Store charts outside Alpine.js reactivity to prevent proxy conflicts
        const globalCharts = {};
        const globalTransferHistory = {};

        function app() {
            return {
                loading: false,
                piaStatus: { connected: false, region_name: null, ip_address: null },
                vpnStatus: { active_count: 0, connections: [] },
                tailscaleStatus: { running: false, exit_node_enabled: false, hostname: null },
                systemHealth: { healthy: false, messages: [] },
                regions: [],
                selectedRegion: '',
                devices: [],
                pollInterval: null,
                networkGraph: null,

                async init() {
                    await this.loadRegions();
                    await this.refreshStatus();

                    // Initialize network graph
                    this.initNetworkGraph();

                    // Poll status every second for real-time charts
                    this.pollInterval = setInterval(() => this.refreshStatus(), 1000);
                },

                async loadRegions() {
                    try {
                        const response = await fetch('/api/settings/regions');
                        const data = await response.json();
                        this.regions = data.regions;
                    } catch (error) {
                        console.error('Failed to load regions:', error);
                    }
                },

                async refreshStatus() {
                    await Promise.all([
                        this.loadVPNStatus(),
                        this.loadTailscaleStatus(),
                        this.loadSystemHealth(),
                        this.loadDevices()
                    ]);

                    // Update visualizations after status is loaded
                    this.$nextTick(() => {
                        this.updateNetworkGraph();
                        this.updateCharts();
                    });
                },

                async loadVPNStatus() {
                    try {
                        const response = await fetch('/api/status/vpn');
                        this.vpnStatus = await response.json();
                    } catch (error) {
                        console.error('Failed to load VPN status:', error);
                        this.vpnStatus = {
                            active_count: 0,
                            connections: []
                        };
                    }
                },

                async loadTailscaleStatus() {
                    try {
                        const response = await fetch('/api/status/tailscale');
                        this.tailscaleStatus = await response.json();
                    } catch (error) {
                        console.error('Failed to load Tailscale status:', error);
                    }
                },

                async loadSystemHealth() {
                    try {
                        const response = await fetch('/api/status/health');
                        this.systemHealth = await response.json();
                    } catch (error) {
                        console.error('Failed to load system health:', error);
                    }
                },

                async loadDevices() {
                    try {
                        const response = await fetch('/api/devices');
                        const data = await response.json();
                        this.devices = data.devices;
                    } catch (error) {
                        console.error('Failed to load devices:', error);
                    }
                },

                async setDeviceRegion(deviceId, regionId) {
                    try {
                        const response = await fetch(`/api/devices/${deviceId}/region`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ region_id: regionId || null })
                        });

                        if (!response.ok) {
                            const error = await response.json();
                            alert('Failed to set device region: ' + error.detail);
                            await this.loadDevices();
                        } else {
                            const data = await response.json();
                            await this.loadDevices();
                            await this.loadVPNStatus();
                            if (data.message) {
                                console.log('✓ ' + data.message);
                            }
                        }
                    } catch (error) {
                        alert('Failed to set device region: ' + error.message);
                        await this.loadDevices();
                    }
                },

                initNetworkGraph() {
                    const container = document.getElementById('network-graph');
                    const width = container.clientWidth;
                    const height = 400;

                    // Create SVG
                    const svg = d3.select('#network-graph')
                        .append('svg')
                        .attr('width', width)
                        .attr('height', height)
                        .attr('viewBox', [0, 0, width, height]);

                    // Add arrow marker
                    svg.append('defs').append('marker')
                        .attr('id', 'arrowhead')
                        .attr('viewBox', '-0 -5 10 10')
                        .attr('refX', 20)
                        .attr('refY', 0)
                        .attr('orient', 'auto')
                        .attr('markerWidth', 8)
                        .attr('markerHeight', 8)
                        .append('svg:path')
                        .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
                        .attr('fill', '#3b82f6');

                    // Create groups for links and nodes
                    const linkGroup = svg.append('g').attr('class', 'links');
                    const nodeGroup = svg.append('g').attr('class', 'nodes');

                    this.networkGraph = { svg, linkGroup, nodeGroup, width, height };
                },

                updateNetworkGraph() {
                    if (!this.networkGraph) return;

                    const { svg, linkGroup, nodeGroup, width, height } = this.networkGraph;

                    // Build graph data
                    const nodes = [];
                    const links = [];

                    // Add router node (center)
                    nodes.push({
                        id: 'router',
                        label: 'PIA Router',
                        type: 'router',
                        x: width / 2,
                        y: height / 2,
                        fx: width / 2,
                        fy: height / 2
                    });

                    // Add PIA exit node nodes (right side)
                    this.vpnStatus.connections.forEach((conn, idx) => {
                        const nodeId = `pia-${conn.interface}`;
                        nodes.push({
                            id: nodeId,
                            label: conn.region_name,
                            type: 'pia',
                            x: width * 0.8,
                            y: height / 2 + (idx - this.vpnStatus.connections.length / 2 + 0.5) * 80
                        });

                        // Link from router to PIA
                        links.push({
                            source: 'router',
                            target: nodeId
                        });
                    });

                    // Add device nodes (left side)
                    const routedDevices = this.devices.filter(d => d.region_id);
                    routedDevices.forEach((device, idx) => {
                        const nodeId = `device-${device.id}`;
                        nodes.push({
                            id: nodeId,
                            label: device.hostname,
                            type: 'device',
                            online: device.online,
                            x: width * 0.2,
                            y: height / 2 + (idx - routedDevices.length / 2 + 0.5) * 60
                        });

                        // Link from device to router
                        links.push({
                            source: nodeId,
                            target: 'router'
                        });
                    });

                    // Update links
                    const link = linkGroup.selectAll('line')
                        .data(links, d => `${d.source}-${d.target}`);

                    link.exit().remove();

                    link.enter()
                        .append('line')
                        .attr('class', 'network-link')
                        .merge(link)
                        .attr('x1', d => {
                            const sourceNode = nodes.find(n => n.id === d.source);
                            return sourceNode ? sourceNode.x : 0;
                        })
                        .attr('y1', d => {
                            const sourceNode = nodes.find(n => n.id === d.source);
                            return sourceNode ? sourceNode.y : 0;
                        })
                        .attr('x2', d => {
                            const targetNode = nodes.find(n => n.id === d.target);
                            return targetNode ? targetNode.x : 0;
                        })
                        .attr('y2', d => {
                            const targetNode = nodes.find(n => n.id === d.target);
                            return targetNode ? targetNode.y : 0;
                        });

                    // Update nodes
                    const node = nodeGroup.selectAll('g')
                        .data(nodes, d => d.id);

                    node.exit().remove();

                    const nodeEnter = node.enter()
                        .append('g')
                        .attr('class', 'network-node');

                    nodeEnter.append('circle')
                        .attr('r', d => d.type === 'router' ? 25 : 20);

                    nodeEnter.append('text')
                        .attr('dy', 30)
                        .attr('text-anchor', 'middle')
                        .attr('class', 'text-gray-900 dark:text-white');

                    nodeEnter.merge(node)
                        .attr('transform', d => `translate(${d.x},${d.y})`)
                        .select('circle')
                        .attr('fill', d => {
                            if (d.type === 'router') return '#3b82f6';
                            if (d.type === 'pia') return '#22c55e';
                            return d.online ? '#10b981' : '#6b7280';
                        });

                    nodeEnter.merge(node)
                        .select('text')
                        .text(d => d.label);
                },

                updateCharts() {
                    // Track which interfaces are still active
                    const activeInterfaces = new Set();

                    // Create/update charts for each VPN connection
                    this.vpnStatus.connections.forEach(conn => {
                        activeInterfaces.add(conn.interface);

                        const chartId = 'chart-' + conn.interface;
                        const canvas = document.getElementById(chartId);

                        if (!canvas) return;

                        // Check if existing chart's canvas is still in the DOM
                        if (globalCharts[conn.interface]) {
                            const existingCanvas = globalCharts[conn.interface].canvas;
                            if (!existingCanvas || !existingCanvas.isConnected) {
                                // Canvas was removed from DOM, destroy the old chart
                                globalCharts[conn.interface].destroy();
                                delete globalCharts[conn.interface];
                            }
                        }

                        // Initialize transfer history for this connection
                        if (!globalTransferHistory[conn.interface]) {
                            globalTransferHistory[conn.interface] = {
                                timestamps: [],
                                rx: [],
                                tx: [],
                                rawRx: [],  // Store raw rates for moving average
                                rawTx: [],  // Store raw rates for moving average
                                prevRx: conn.transfer_rx_bytes || 0,
                                prevTx: conn.transfer_tx_bytes || 0,
                                prevTime: Date.now()
                            };
                        }

                        const history = globalTransferHistory[conn.interface];
                        const now = Date.now();
                        const timeDelta = (now - history.prevTime) / 1000; // seconds

                        // Calculate rates (bytes per second)
                        const rxBytes = conn.transfer_rx_bytes || 0;
                        const txBytes = conn.transfer_tx_bytes || 0;

                        // Validate time delta to prevent magnitude errors
                        let rawRxRate = 0;
                        let rawTxRate = 0;

                        if (timeDelta > 0.5 && timeDelta < 10) { // Reasonable time window (0.5s to 10s)
                            const rxDelta = rxBytes - history.prevRx;
                            const txDelta = txBytes - history.prevTx;

                            // Calculate instantaneous rate
                            rawRxRate = rxDelta / timeDelta;
                            rawTxRate = txDelta / timeDelta;

                            // Sanity check: if rate exceeds 1 Gbps, something is wrong
                            const maxRate = 1024 * 1024 * 1024 / 8; // 1 Gbps in bytes/sec
                            if (rawRxRate > maxRate) rawRxRate = 0;
                            if (rawTxRate > maxRate) rawTxRate = 0;
                        }

                        history.prevRx = rxBytes;
                        history.prevTx = txBytes;
                        history.prevTime = now;

                        // Store raw rates
                        history.rawRx.push(Math.max(0, rawRxRate));
                        history.rawTx.push(Math.max(0, rawTxRate));

                        // Keep last 30 raw samples for moving average calculation
                        if (history.rawRx.length > 30) {
                            history.rawRx.shift();
                            history.rawTx.shift();
                        }

                        // Calculate simple moving average over last 20 samples for very smooth lines
                        const windowSize = Math.min(20, history.rawRx.length);
                        const recentRx = history.rawRx.slice(-windowSize);
                        const recentTx = history.rawTx.slice(-windowSize);

                        const smoothedRx = recentRx.reduce((a, b) => a + b, 0) / windowSize;
                        const smoothedTx = recentTx.reduce((a, b) => a + b, 0) / windowSize;

                        // Add to history (keep last 120 data points = 2 minutes at 1s polling)
                        history.timestamps.push(new Date().toLocaleTimeString());
                        history.rx.push(smoothedRx);
                        history.tx.push(smoothedTx);


                        if (history.timestamps.length > 120) {
                            history.timestamps.shift();
                            history.rx.shift();
                            history.tx.shift();
                        }

                        // Create or update chart
                        if (!globalCharts[conn.interface]) {
                            const ctx = canvas.getContext('2d');
                            globalCharts[conn.interface] = new Chart(ctx, {
                                type: 'line',
                                data: {
                                    labels: [...history.timestamps],
                                    datasets: [
                                        {
                                            label: 'Download',
                                            data: [...history.rx],
                                            borderColor: 'rgb(34, 197, 94)',
                                            backgroundColor: 'rgba(34, 197, 94, 0.1)',
                                            tension: 0.4,
                                            fill: true,
                                            pointRadius: 0
                                        },
                                        {
                                            label: 'Upload',
                                            data: [...history.tx],
                                            borderColor: 'rgb(59, 130, 246)',
                                            backgroundColor: 'rgba(59, 130, 246, 0.1)',
                                            tension: 0.4,
                                            fill: true,
                                            pointRadius: 0
                                        }
                                    ]
                                },
                                options: {
                                    responsive: true,
                                    maintainAspectRatio: false,
                                    interaction: {
                                        intersect: false,
                                        mode: 'index'
                                    },
                                    plugins: {
                                        legend: {
                                            display: true,
                                            position: 'bottom',
                                            labels: {
                                                color: document.documentElement.classList.contains('dark') ? '#9ca3af' : '#4b5563',
                                                boxWidth: 12,
                                                padding: 10,
                                                font: { size: 10 }
                                            }
                                        },
                                        tooltip: {
                                            callbacks: {
                                                label: function(context) {
                                                    return context.dataset.label + ': ' + formatBytes(context.parsed.y) + '/s';
                                                }
                                            }
                                        }
                                    },
                                    scales: {
                                        x: {
                                            display: false
                                        },
                                        y: {
                                            beginAtZero: true,
                                            ticks: {
                                                color: document.documentElement.classList.contains('dark') ? '#9ca3af' : '#6b7280',
                                                callback: function(value) {
                                                    return formatBytes(value) + '/s';
                                                },
                                                font: { size: 10 }
                                            },
                                            grid: {
                                                color: document.documentElement.classList.contains('dark') ? '#374151' : '#e5e7eb'
                                            }
                                        }
                                    }
                                }
                            });
                        } else {
                            // Update existing chart - verify canvas is still valid
                            const chart = globalCharts[conn.interface];
                            if (chart && chart.canvas && chart.canvas.isConnected) {
                                try {
                                    chart.data.labels = [...history.timestamps];
                                    chart.data.datasets[0].data = [...history.rx];
                                    chart.data.datasets[1].data = [...history.tx];
                                    chart.update('none');
                                } catch (e) {
                                    console.error('Chart update failed:', e);
                                    // Destroy broken chart
                                    chart.destroy();
                                    delete globalCharts[conn.interface];
                                }
                            }
                        }
                    });

                    // Clean up charts for interfaces that no longer exist
                    Object.keys(globalCharts).forEach(interface_name => {
                        if (!activeInterfaces.has(interface_name)) {
                            globalCharts[interface_name].destroy();
                            delete globalCharts[interface_name];
                        }
                    });
                },

                getCurrentRate(interface_name, direction) {
                    const history = globalTransferHistory[interface_name];
                    if (!history || !history[direction] || history[direction].length === 0) {
                        return 0;
                    }
                    // Return the latest rate
                    return history[direction][history[direction].length - 1];
                },

                formatRate(bytesPerSecond) {
                    return formatBytes(bytesPerSecond) + '/s';
                }
            }
        }

        // Utility function for formatting bytes
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
    </script>
</body>
</html>
