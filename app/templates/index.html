<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tailscale PIA Router</title>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/uplot@1.6.32/dist/uPlot.iife.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/uplot@1.6.32/dist/uPlot.min.css">
    <script>
        tailwind.config = {
            darkMode: 'media'
        }
    </script>
    <style>
        .network-link {
            stroke: #3b82f6;
            stroke-width: 2px;
            fill: none;
            marker-end: url(#arrowhead);
        }
        .network-node {
            cursor: pointer;
        }
        .network-node circle {
            stroke: #fff;
            stroke-width: 2px;
        }
        .network-node text {
            font-size: 12px;
            pointer-events: none;
            fill: #1f2937;
        }
        @media (prefers-color-scheme: dark) {
            .network-node text {
                fill: #f9fafb;
            }
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900" x-data="app()" x-init="init()">
    <div class="min-h-screen">
        <!-- Header -->
        <header class="bg-white dark:bg-gray-800 shadow">
            <div class="max-w-7xl mx-auto px-4 py-6 sm:px-6 lg:px-8">
                <div class="flex justify-between items-center">
                    <h1 class="text-3xl font-bold text-gray-900 dark:text-white">Tailscale PIA Router</h1>
                    <div class="flex items-center space-x-6">
                        <!-- Compact Status Indicators -->
                        <div class="flex items-center space-x-2">
                            <div :class="vpnStatus.active_count > 0 ? 'bg-green-500' : 'bg-gray-500'" class="w-2.5 h-2.5 rounded-full"></div>
                            <span class="text-sm text-gray-700 dark:text-gray-300">
                                <span x-text="vpnStatus.active_count"></span> VPN
                            </span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <div :class="tailscaleStatus.running ? 'bg-green-500' : 'bg-red-500'" class="w-2.5 h-2.5 rounded-full"></div>
                            <span class="text-sm text-gray-700 dark:text-gray-300">Tailscale</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <div :class="systemHealth.healthy ? 'bg-green-500' : 'bg-yellow-500'" class="w-2.5 h-2.5 rounded-full"></div>
                            <span class="text-sm text-gray-700 dark:text-gray-300">System</span>
                        </div>
                        <a href="/settings" class="text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300 text-sm">Settings</a>
                    </div>
                </div>
            </div>
        </header>

        <main class="max-w-7xl mx-auto px-4 py-6 sm:px-6 lg:px-8">
            <!-- VPN Connection Cards Grid -->
            <div x-show="vpnStatus.connections && vpnStatus.connections.length > 0">
                <h2 class="text-xl font-semibold text-gray-900 dark:text-white mb-4">VPN Connections</h2>
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-6">
                    <template x-for="conn in vpnStatus.connections" :key="conn.region_id">
                        <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
                            <!-- Connection Header -->
                            <div class="flex items-center justify-between mb-4">
                                <div>
                                    <h3 class="text-lg font-semibold text-gray-900 dark:text-white" x-text="conn.region_name"></h3>
                                    <p class="text-xs text-gray-500 dark:text-gray-400" x-text="conn.interface"></p>
                                </div>
                                <div class="bg-green-500 w-3 h-3 rounded-full"></div>
                            </div>

                            <!-- Stats -->
                            <div class="space-y-2 mb-4">
                                <div class="flex justify-between text-sm">
                                    <span class="text-gray-600 dark:text-gray-400">Last Handshake</span>
                                    <span class="text-gray-900 dark:text-white font-medium" x-text="conn.last_handshake || 'N/A'"></span>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <span class="text-gray-600 dark:text-gray-400">Total ↓</span>
                                    <span class="text-gray-900 dark:text-white font-medium" x-text="conn.transfer_rx || '0 B'"></span>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <span class="text-gray-600 dark:text-gray-400">Total ↑</span>
                                    <span class="text-gray-900 dark:text-white font-medium" x-text="conn.transfer_tx || '0 B'"></span>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <span class="text-gray-600 dark:text-gray-400">Current ↓</span>
                                    <span class="text-green-600 dark:text-green-400 font-medium" x-text="formatRate(getCurrentRate(conn.interface, 'rx'))"></span>
                                </div>
                                <div class="flex justify-between text-sm">
                                    <span class="text-gray-600 dark:text-gray-400">Current ↑</span>
                                    <span class="text-blue-600 dark:text-blue-400 font-medium" x-text="formatRate(getCurrentRate(conn.interface, 'tx'))"></span>
                                </div>
                            </div>

                            <!-- Throughput Chart -->
                            <div class="mt-4">
                                <div class="text-xs text-gray-500 dark:text-gray-400 mb-2">Throughput (last 2 minutes)</div>
                                <div :id="'chart-' + conn.interface" style="height: 150px;"></div>
                            </div>

                            <!-- Devices using this connection -->
                            <div class="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
                                <div class="text-xs font-medium text-gray-700 dark:text-gray-300 mb-2">Devices</div>
                                <div class="space-y-1">
                                    <template x-for="device in devices.filter(d => d.region_id === conn.region_id)" :key="device.id">
                                        <div class="text-xs text-gray-600 dark:text-gray-400 flex items-center space-x-1">
                                            <div :class="device.online ? 'bg-green-500' : 'bg-gray-500'" class="w-1.5 h-1.5 rounded-full"></div>
                                            <span x-text="device.hostname"></span>
                                        </div>
                                    </template>
                                </div>
                            </div>
                        </div>
                    </template>
                </div>
            </div>

            <!-- Network Topology Mesh -->
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6 mb-6">
                <h2 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Network Topology</h2>
                <div id="network-graph" class="w-full bg-gray-100 dark:bg-gray-700 rounded" style="height: 400px;"></div>
            </div>

            <!-- Device List -->
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow p-6">
                <h2 class="text-lg font-semibold text-gray-900 dark:text-white mb-4">Tailscale Devices</h2>
                <div class="overflow-visible">
                    <table class="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
                        <thead class="bg-gray-50 dark:bg-gray-700">
                            <tr>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Device</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">IP Address</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">OS</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">Status</th>
                                <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">VPN Region</th>
                            </tr>
                        </thead>
                        <template x-for="device in devices" :key="device.id">
                            <tbody class="bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">
                                <tr class="hover:bg-gray-50 dark:hover:bg-gray-700">
                                    <td class="px-6 py-4 whitespace-nowrap">
                                        <div class="text-sm font-medium text-gray-900 dark:text-white" x-text="device.hostname"></div>
                                    </td>
                                    <td class="px-6 py-4 whitespace-nowrap">
                                        <div class="text-sm text-gray-600 dark:text-gray-400" x-text="device.ip_addresses.join(', ')"></div>
                                    </td>
                                    <td class="px-6 py-4 whitespace-nowrap">
                                        <div class="text-sm text-gray-600 dark:text-gray-400" x-text="device.os || 'Unknown'"></div>
                                    </td>
                                    <td class="px-6 py-4 whitespace-nowrap">
                                        <span :class="device.online ? 'bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200' : 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300'" class="px-2 py-1 text-xs rounded-full" x-text="device.online ? 'Online' : 'Offline'"></span>
                                    </td>
                                    <td class="px-6 py-4">
                                        <select
                                            @change="setDeviceRegion(device.id, $event.target.value)"
                                            class="text-sm rounded-md border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:text-white shadow-sm focus:border-blue-500 focus:ring-blue-500">
                                            <option value="">-- No VPN --</option>
                                            <template x-for="region in regions" :key="region.id">
                                                <option :value="region.id" :selected="device.region_id === region.id" x-text="`${region.name} (${region.country})`"></option>
                                            </template>
                                        </select>
                                        <div x-show="device.region_id" class="mt-1 text-xs" :class="device.routing_enabled ? 'text-green-600 dark:text-green-400' : 'text-gray-500 dark:text-gray-400'">
                                            <span x-text="device.routing_enabled ? '✓ Routing enabled' : '⏳ Connecting...'"></span>
                                            <span x-show="device.auto_managed" class="ml-1 text-gray-500 dark:text-gray-400">(Set exit node in Tailscale app)</span>
                                        </div>
                                    </td>
                                </tr>
                            </tbody>
                        </template>
                    </table>
                    <div x-show="devices.length === 0" class="text-center py-4 text-gray-500 dark:text-gray-400">
                        No devices found
                    </div>
                </div>
            </div>
        </main>
    </div>

    <script>
        // Store charts outside Alpine.js reactivity to prevent proxy conflicts
        const globalCharts = {};
        const globalTransferHistory = {};

        function app() {
            return {
                loading: false,
                piaStatus: { connected: false, region_name: null, ip_address: null },
                vpnStatus: { active_count: 0, connections: [] },
                tailscaleStatus: { running: false, exit_node_enabled: false, hostname: null },
                systemHealth: { healthy: false, messages: [] },
                regions: [],
                selectedRegion: '',
                devices: [],
                pollInterval: null,
                networkGraph: null,

                async init() {
                    await this.loadRegions();
                    await this.refreshStatus();

                    // Initialize network graph
                    this.initNetworkGraph();

                    // Poll status every second for real-time charts
                    this.pollInterval = setInterval(() => this.refreshStatus(), 1000);
                },

                async loadRegions() {
                    try {
                        const response = await fetch('/api/settings/regions');
                        const data = await response.json();
                        this.regions = data.regions;
                    } catch (error) {
                        console.error('Failed to load regions:', error);
                    }
                },

                async refreshStatus() {
                    await Promise.all([
                        this.loadVPNStatus(),
                        this.loadTailscaleStatus(),
                        this.loadSystemHealth(),
                        this.loadDevices()
                    ]);

                    // Update visualizations after status is loaded
                    this.$nextTick(() => {
                        this.updateNetworkGraph();
                        this.updateCharts();
                    });
                },

                async loadVPNStatus() {
                    try {
                        const response = await fetch('/api/status/vpn');
                        this.vpnStatus = await response.json();
                    } catch (error) {
                        console.error('Failed to load VPN status:', error);
                        this.vpnStatus = {
                            active_count: 0,
                            connections: []
                        };
                    }
                },

                async loadTailscaleStatus() {
                    try {
                        const response = await fetch('/api/status/tailscale');
                        this.tailscaleStatus = await response.json();
                    } catch (error) {
                        console.error('Failed to load Tailscale status:', error);
                    }
                },

                async loadSystemHealth() {
                    try {
                        const response = await fetch('/api/status/health');
                        this.systemHealth = await response.json();
                    } catch (error) {
                        console.error('Failed to load system health:', error);
                    }
                },

                async loadDevices() {
                    try {
                        const response = await fetch('/api/devices');
                        const data = await response.json();
                        this.devices = data.devices;
                    } catch (error) {
                        console.error('Failed to load devices:', error);
                    }
                },

                async setDeviceRegion(deviceId, regionId) {
                    try {
                        const response = await fetch(`/api/devices/${deviceId}/region`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ region_id: regionId || null })
                        });

                        if (!response.ok) {
                            const error = await response.json();
                            alert('Failed to set device region: ' + error.detail);
                            await this.loadDevices();
                        } else {
                            const data = await response.json();
                            await this.loadDevices();
                            await this.loadVPNStatus();
                            if (data.message) {
                                console.log('✓ ' + data.message);
                            }
                        }
                    } catch (error) {
                        alert('Failed to set device region: ' + error.message);
                        await this.loadDevices();
                    }
                },

                initNetworkGraph() {
                    // Prevent duplicate initialization
                    if (this.networkGraph) return;

                    const container = document.getElementById('network-graph');
                    if (!container) return;

                    const width = container.clientWidth;
                    const height = 400;

                    // Clear any existing SVG first
                    d3.select('#network-graph').selectAll('svg').remove();

                    // Create SVG
                    const svg = d3.select('#network-graph')
                        .append('svg')
                        .attr('width', width)
                        .attr('height', height)
                        .attr('viewBox', [0, 0, width, height]);

                    // Add arrow marker
                    svg.append('defs').append('marker')
                        .attr('id', 'arrowhead')
                        .attr('viewBox', '-0 -5 10 10')
                        .attr('refX', 20)
                        .attr('refY', 0)
                        .attr('orient', 'auto')
                        .attr('markerWidth', 8)
                        .attr('markerHeight', 8)
                        .append('svg:path')
                        .attr('d', 'M 0,-5 L 10 ,0 L 0,5')
                        .attr('fill', '#3b82f6');

                    // Create groups for links and nodes
                    const linkGroup = svg.append('g').attr('class', 'links');
                    const nodeGroup = svg.append('g').attr('class', 'nodes');

                    this.networkGraph = { svg, linkGroup, nodeGroup, width, height };
                },

                updateNetworkGraph() {
                    if (!this.networkGraph) return;

                    const { svg, linkGroup, nodeGroup, width, height } = this.networkGraph;

                    // Build graph data with FIXED positions
                    const nodes = [];
                    const links = [];
                    const centerX = width / 2;
                    const centerY = height / 2;
                    const meshRadius = 140;

                    // Position PIA exit nodes ONLY on left and right sides
                    const piaCount = this.vpnStatus.connections.length;
                    const piaNodes = {};
                    const leftPiaNodes = [];
                    const rightPiaNodes = [];

                    this.vpnStatus.connections.forEach((conn, idx) => {
                        const nodeId = `pia-${conn.region_id}`;

                        // Alternate between left and right sides
                        const isLeft = idx % 2 === 0;
                        const side = isLeft ? leftPiaNodes : rightPiaNodes;

                        const piaNode = {
                            id: nodeId,
                            label: conn.region_name,
                            type: 'pia',
                            region_id: conn.region_id,
                            isLeft: isLeft,
                            sideIndex: side.length
                        };

                        side.push(piaNode);
                        nodes.push(piaNode);
                        piaNodes[conn.region_id] = piaNode;
                    });

                    // Position left PIA nodes
                    leftPiaNodes.forEach((node, idx) => {
                        node.x = 80;
                        node.y = centerY + (idx - (leftPiaNodes.length - 1) / 2) * 100;
                    });

                    // Position right PIA nodes
                    rightPiaNodes.forEach((node, idx) => {
                        node.x = width - 80;
                        node.y = centerY + (idx - (rightPiaNodes.length - 1) / 2) * 100;
                    });

                    // Order devices intelligently: group by exit node side to minimize crossings
                    const leftSideDevices = [];
                    const rightSideDevices = [];
                    const unroutedDevices = [];

                    this.devices.forEach(device => {
                        if (device.region_id && piaNodes[device.region_id]) {
                            const piaNode = piaNodes[device.region_id];
                            if (piaNode.isLeft) {
                                leftSideDevices.push(device);
                            } else {
                                rightSideDevices.push(device);
                            }
                        } else {
                            unroutedDevices.push(device);
                        }
                    });

                    // Create ordered device list: left-exit, unrouted, right-exit
                    // This ordering minimizes crossings while maintaining ring
                    const orderedDevices = [
                        ...leftSideDevices,
                        ...unroutedDevices,
                        ...rightSideDevices
                    ];

                    // Position ALL devices evenly in a RING around full 360°
                    const deviceCount = orderedDevices.length;
                    orderedDevices.forEach((device, idx) => {
                        // Distribute evenly around full circle
                        const angle = (idx / deviceCount) * 2 * Math.PI - Math.PI / 2; // Start at top

                        nodes.push({
                            id: `device-${device.id}`,
                            label: device.hostname,
                            type: 'device',
                            online: device.online,
                            region_id: device.region_id,
                            x: centerX + meshRadius * Math.cos(angle),
                            y: centerY + meshRadius * Math.sin(angle)
                        });
                    });

                    // Create mesh connections between all devices
                    const deviceNodes = nodes.filter(n => n.type === 'device');
                    for (let i = 0; i < deviceNodes.length; i++) {
                        for (let j = i + 1; j < deviceNodes.length; j++) {
                            links.push({
                                source: deviceNodes[i],
                                target: deviceNodes[j],
                                type: 'mesh'
                            });
                        }
                    }

                    // Add exit connections from devices to their PIA regions
                    deviceNodes.forEach(deviceNode => {
                        if (deviceNode.region_id) {
                            const piaNode = piaNodes[deviceNode.region_id];
                            if (piaNode) {
                                links.push({
                                    source: deviceNode,
                                    target: piaNode,
                                    type: 'exit'
                                });
                            }
                        }
                    });

                    // Update links
                    const link = linkGroup.selectAll('line')
                        .data(links, d => `${d.source.id}-${d.target.id}`);

                    link.exit().remove();

                    const linkEnter = link.enter()
                        .append('line')
                        .attr('stroke', d => d.type === 'mesh' ? '#6b7280' : '#3b82f6')
                        .attr('stroke-width', d => d.type === 'mesh' ? 1.5 : 2.5)
                        .attr('stroke-opacity', d => d.type === 'mesh' ? 0.6 : 0.9);

                    linkEnter.merge(link)
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y);

                    // Update nodes
                    const node = nodeGroup.selectAll('g')
                        .data(nodes, d => d.id);

                    node.exit().remove();

                    const nodeEnter = node.enter()
                        .append('g')
                        .attr('class', 'network-node');

                    nodeEnter.append('circle')
                        .attr('r', d => d.type === 'pia' ? 25 : 20);

                    nodeEnter.append('text')
                        .attr('dy', 35)
                        .attr('text-anchor', 'middle')
                        .attr('class', 'text-gray-900 dark:text-white')
                        .style('font-size', '11px');

                    const allNodes = nodeEnter.merge(node);

                    allNodes
                        .attr('transform', d => `translate(${d.x},${d.y})`);

                    allNodes.select('circle')
                        .attr('fill', d => {
                            if (d.type === 'pia') return '#22c55e';
                            return d.online ? '#3b82f6' : '#6b7280';
                        })
                        .attr('stroke', '#fff')
                        .attr('stroke-width', 2);

                    allNodes.select('text')
                        .text(d => d.label);
                },

                updateCharts() {
                    // Track which interfaces are still active
                    const activeInterfaces = new Set();

                    // Create/update charts for each VPN connection
                    this.vpnStatus.connections.forEach(conn => {
                        activeInterfaces.add(conn.interface);

                        const chartId = 'chart-' + conn.interface;
                        const chartDiv = document.getElementById(chartId);

                        if (!chartDiv) return;

                        // Check if existing chart is still valid
                        if (globalCharts[conn.interface]) {
                            const chart = globalCharts[conn.interface];
                            if (!chart || !chart.root || !chart.root.isConnected) {
                                // Chart was removed from DOM, destroy it
                                if (chart && chart.destroy) chart.destroy();
                                delete globalCharts[conn.interface];
                            }
                        }

                        // Initialize transfer history for this connection
                        if (!globalTransferHistory[conn.interface]) {
                            globalTransferHistory[conn.interface] = {
                                timestamps: [],  // Unix timestamps in seconds
                                rx: [],
                                tx: [],
                                rawRx: [],  // Store raw rates for moving average
                                rawTx: [],  // Store raw rates for moving average
                                prevRx: conn.transfer_rx_bytes || 0,
                                prevTx: conn.transfer_tx_bytes || 0,
                                prevTime: Date.now()
                            };
                        }

                        const history = globalTransferHistory[conn.interface];
                        const now = Date.now();
                        const timeDelta = (now - history.prevTime) / 1000; // seconds

                        // Calculate rates (bytes per second)
                        const rxBytes = conn.transfer_rx_bytes || 0;
                        const txBytes = conn.transfer_tx_bytes || 0;

                        // Calculate rates (validate time delta to prevent magnitude errors)
                        let rawRxRate = 0;
                        let rawTxRate = 0;

                        if (timeDelta > 0.1 && timeDelta < 30) { // Reasonable time window (0.1s to 30s)
                            const rxDelta = rxBytes - history.prevRx;
                            const txDelta = txBytes - history.prevTx;

                            // Debug logging for Singapore
                            if (conn.interface === 'pia-sg') {
                                console.log(`[${conn.interface}] RX: ${rxBytes} (prev: ${history.prevRx}, delta: ${rxDelta}), Time: ${timeDelta.toFixed(2)}s`);
                            }

                            // Calculate instantaneous rate
                            rawRxRate = rxDelta / timeDelta;
                            rawTxRate = txDelta / timeDelta;

                            // More debug logging
                            if (conn.interface === 'pia-sg') {
                                console.log(`[${conn.interface}] Calculated rate: ${(rawRxRate / 1024 / 1024).toFixed(2)} MB/s`);
                            }

                            // Sanity check: if rate exceeds 1 Gbps, something is wrong
                            const maxRate = 1024 * 1024 * 1024 / 8; // 1 Gbps in bytes/sec
                            if (rawRxRate > maxRate) {
                                console.warn(`Rate ${rawRxRate} exceeds 1 Gbps limit for ${conn.interface}`);
                                rawRxRate = 0;
                            }
                            if (rawTxRate > maxRate) {
                                console.warn(`Rate ${rawTxRate} exceeds 1 Gbps limit for ${conn.interface}`);
                                rawTxRate = 0;
                            }
                        } else {
                            console.warn(`Invalid timeDelta ${timeDelta} for ${conn.interface}, skipping rate calculation`);
                        }

                        history.prevRx = rxBytes;
                        history.prevTx = txBytes;
                        history.prevTime = now;

                        // Store raw rates
                        history.rawRx.push(Math.max(0, rawRxRate));
                        history.rawTx.push(Math.max(0, rawTxRate));

                        // Keep last 30 raw samples for moving average calculation
                        if (history.rawRx.length > 30) {
                            history.rawRx.shift();
                            history.rawTx.shift();
                        }

                        // Calculate simple moving average over last 10 samples for smooth but responsive lines
                        const windowSize = Math.min(10, history.rawRx.length);
                        const recentRx = history.rawRx.slice(-windowSize);
                        const recentTx = history.rawTx.slice(-windowSize);

                        const smoothedRx = recentRx.reduce((a, b) => a + b, 0) / windowSize;
                        const smoothedTx = recentTx.reduce((a, b) => a + b, 0) / windowSize;

                        // Add to history (keep last 120 data points = 2 minutes at 1s polling)
                        // uPlot requires Unix timestamps in seconds
                        history.timestamps.push(Math.floor(now / 1000));
                        history.rx.push(smoothedRx);
                        history.tx.push(smoothedTx);

                        if (history.timestamps.length > 120) {
                            history.timestamps.shift();
                            history.rx.shift();
                            history.tx.shift();
                        }

                        // Create or update chart
                        if (!globalCharts[conn.interface]) {
                            // uPlot options
                            const isDark = document.documentElement.classList.contains('dark');
                            const opts = {
                                width: chartDiv.clientWidth,
                                height: 150,
                                series: [
                                    {
                                        label: 'Time'
                                    },
                                    {
                                        label: 'Download',
                                        stroke: 'rgb(34, 197, 94)',
                                        fill: 'rgba(34, 197, 94, 0.1)',
                                        width: 2,
                                        value: (self, rawValue) => rawValue == null ? '-' : formatBytes(rawValue) + '/s'
                                    },
                                    {
                                        label: 'Upload',
                                        stroke: 'rgb(59, 130, 246)',
                                        fill: 'rgba(59, 130, 246, 0.1)',
                                        width: 2,
                                        value: (self, rawValue) => rawValue == null ? '-' : formatBytes(rawValue) + '/s'
                                    }
                                ],
                                axes: [
                                    {
                                        // X-axis (time)
                                        show: false
                                    },
                                    {
                                        // Y-axis (bytes/s)
                                        stroke: isDark ? '#9ca3af' : '#6b7280',
                                        grid: {
                                            stroke: isDark ? '#374151' : '#e5e7eb',
                                            width: 1
                                        },
                                        values: (self, ticks) => ticks.map(v => formatBytes(v) + '/s'),
                                        size: 50
                                    }
                                ],
                                legend: {
                                    show: false  // Hide legend, we show current rates in the card UI
                                },
                                cursor: {
                                    drag: {
                                        x: false,
                                        y: false
                                    }
                                }
                            };

                            // uPlot data format: [[timestamps], [rx_values], [tx_values]]
                            const data = [
                                [...history.timestamps],
                                [...history.rx],
                                [...history.tx]
                            ];

                            globalCharts[conn.interface] = new uPlot(opts, data, chartDiv);
                        } else {
                            // Update existing chart
                            const chart = globalCharts[conn.interface];
                            if (chart && chart.root && chart.root.isConnected) {
                                try {
                                    // uPlot data format: [[timestamps], [rx_values], [tx_values]]
                                    const data = [
                                        [...history.timestamps],
                                        [...history.rx],
                                        [...history.tx]
                                    ];
                                    chart.setData(data);
                                } catch (e) {
                                    console.error('Chart update failed:', e);
                                    // Destroy broken chart
                                    chart.destroy();
                                    delete globalCharts[conn.interface];
                                }
                            }
                        }
                    });

                    // Clean up charts for interfaces that no longer exist
                    Object.keys(globalCharts).forEach(interface_name => {
                        if (!activeInterfaces.has(interface_name)) {
                            globalCharts[interface_name].destroy();
                            delete globalCharts[interface_name];
                        }
                    });
                },

                getCurrentRate(interface_name, direction) {
                    const history = globalTransferHistory[interface_name];
                    if (!history || !history[direction] || history[direction].length === 0) {
                        return 0;
                    }
                    // Return the latest rate
                    return history[direction][history[direction].length - 1];
                },

                formatRate(bytesPerSecond) {
                    return formatBytes(bytesPerSecond) + '/s';
                }
            }
        }

        // Utility function for formatting bytes
        function formatBytes(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }
    </script>
</body>
</html>
