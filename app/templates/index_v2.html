<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PIA Router - Geographic Topology</title>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
    <script src="https://cdn.jsdelivr.net/npm/uplot@1.6.24/dist/uPlot.iife.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/uplot@1.6.24/dist/uPlot.min.css">
    <style>
        /* Hide elements until Alpine.js initializes */
        [x-cloak] { display: none !important; }

        /* Prevent scrolling on main viewport */
        html, body {
            overflow-x: hidden;
            max-width: 100vw;
            background: #0a0e1a;
        }

        /* Topology container */
        #topology-graph {
            background: linear-gradient(135deg, #0a0e1a 0%, #0f172a 100%);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        /* World map layer */
        .map-layer path {
            fill: #1e3a5f;
            stroke: #334155;
            stroke-width: 0.5px;
            opacity: 0.25;
        }

        /* Mesh connection lines - 3D effect with shadow */
        .network-link-mesh {
            stroke: #475569;
            stroke-width: 1;
            stroke-dasharray: 4 4;
            fill: none;
            opacity: 0.3;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.4));
        }

        .network-link-mesh.dimmed {
            opacity: 0.1;
        }

        /* VPN route lines - static background paths (canvas handles animation) */
        .network-link-vpn {
            stroke: #60a5fa;
            stroke-width: 1.5;
            fill: none;
            opacity: 0.15;
            /* Subtle static line - animation happens on canvas overlay */
        }

        .network-link-vpn.dimmed {
            opacity: 0.08;
            stroke: #475569;
        }

        .network-link-vpn:hover,
        .network-link-vpn.highlighted {
            stroke: #fbbf24;
            opacity: 0.2;
            filter: drop-shadow(0 0 4px rgba(251, 191, 36, 0.8));
        }

        /* Endpoint nodes (geographic PIA servers) - smaller with glow */
        .endpoint-node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .endpoint-node circle {
            filter: drop-shadow(0 0 6px rgba(16, 185, 129, 0.5));
        }

        .endpoint-node.dimmed circle {
            opacity: 0.3;
            filter: drop-shadow(0 0 2px rgba(16, 185, 129, 0.2));
        }

        .endpoint-node:hover circle {
            transform: scale(1.2);
            filter: drop-shadow(0 0 10px rgba(16, 185, 129, 0.8));
        }

        .endpoint-node.selected circle {
            filter: brightness(1.3) drop-shadow(0 0 12px rgba(251, 191, 36, 0.9));
        }

        /* Mesh nodes (Tailscale devices) - 3D depth with shadows */
        .mesh-node {
            cursor: pointer;
            transition: all 0.3s ease;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.5));
        }

        .mesh-node.dimmed {
            opacity: 0.3;
        }

        .mesh-node:hover {
            filter: brightness(1.2) drop-shadow(0 6px 12px rgba(0, 0, 0, 0.6));
        }

        .mesh-node.selected {
            filter: brightness(1.5) drop-shadow(0 0 12px rgba(59, 130, 246, 0.8));
        }

        /* Labels with dark halo for readability */
        .endpoint-label {
            font-size: 11px;
            font-weight: 600;
            fill: #ffffff;
            paint-order: stroke;
            stroke: #000000;
            stroke-width: 3px;
            stroke-linecap: round;
            stroke-linejoin: round;
            pointer-events: none;
        }

        .endpoint-label.dimmed {
            opacity: 0.3;
        }

        .mesh-label {
            font-size: 10px;
            font-weight: 500;
            fill: #f1f5f9;
            opacity: 1;
            paint-order: stroke;
            stroke: #000000;
            stroke-width: 2.5px;
            stroke-linecap: round;
            stroke-linejoin: round;
            pointer-events: none;
        }

        .mesh-label.dimmed {
            opacity: 0.3;
        }

        /* All Endpoints pill */
        .all-endpoints-pill {
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            border: 1px solid #475569;
            transition: all 0.3s ease;
        }

        .all-endpoints-pill.active {
            background: linear-gradient(135deg, #1e40af 0%, #2563eb 100%);
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
        }

        .all-endpoints-pill:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        /* Equal-width endpoint pill styles */
        .endpoint-pill-equal {
            flex: 1 1 0;
            min-width: 200px;
            max-width: 280px;
            border-width: 1px;
        }

        .endpoint-pill-equal:hover:not(.bg-blue-600) {
            background-color: #334155 !important;
        }

        /* Hover state for slate-750 */
        .hover\:bg-slate-750:hover {
            background-color: #334155;
        }

        /* Map expand toggle button */
        .expand-toggle {
            position: absolute;
            top: 12px;
            right: 12px;
            z-index: 10;
            background: rgba(30, 41, 59, 0.9);
            border: 1px solid #475569;
            border-radius: 6px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .expand-toggle:hover {
            background: rgba(51, 65, 85, 0.9);
            border-color: #64748b;
        }

        /* Device table styles */
        .device-table {
            font-size: 14px;
        }

        .device-row {
            height: 40px;
            transition: background-color 0.2s ease;
        }

        .device-row:hover {
            background-color: rgba(59, 130, 246, 0.1);
        }

        .device-row.selected {
            background-color: rgba(59, 130, 246, 0.2);
        }

        /* Status indicators */
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        /* Custom scrollbar for device table */
        .device-table-container::-webkit-scrollbar {
            width: 6px;
        }

        .device-table-container::-webkit-scrollbar-track {
            background: #1e293b;
        }

        .device-table-container::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 3px;
        }

        /* Transition for layout changes */
        .topology-container,
        .table-container {
            transition: width 0.3s ease;
        }
    </style>
</head>
<body class="bg-slate-950 text-slate-100" x-data="app()" x-init="init()">
    <!-- Header (60px) -->
    <header class="bg-slate-900 border-b border-slate-800 px-6 py-3">
        <div class="flex items-center justify-between">
            <h1 class="text-xl font-bold text-white">PIA Router - Geographic Topology</h1>
            <div class="flex items-center space-x-6">
                <!-- Compact Status Indicators -->
                <div class="flex items-center space-x-2">
                    <div :class="vpnStatus.active_count > 0 ? 'bg-green-500' : 'bg-slate-500'" class="status-dot"></div>
                    <span class="text-sm text-slate-300"><span x-text="vpnStatus.active_count"></span> VPN</span>
                </div>
                <div class="flex items-center space-x-2">
                    <div :class="tailscaleStatus.running ? 'bg-green-500' : 'bg-red-500'" class="status-dot"></div>
                    <span class="text-sm text-slate-300">Tailscale</span>
                </div>
                <div class="flex items-center space-x-2">
                    <div :class="systemHealth.healthy ? 'bg-green-500' : 'bg-yellow-500'" class="status-dot"></div>
                    <span class="text-sm text-slate-300">System</span>
                </div>
                <a href="/settings" class="text-blue-400 hover:text-blue-300 text-sm font-medium">Settings</a>
                <a href="/" class="text-slate-400 hover:text-slate-300 text-sm">Classic View</a>
            </div>
        </div>
    </header>

    <!-- Endpoint Pills - Equal Width, Multi-Row Wrap, Two-Line Layout -->
    <div class="bg-slate-900 border-b border-slate-800 px-6 py-3">
        <div class="flex items-center gap-3 mb-2">
            <span class="text-sm text-slate-400 flex-shrink-0">Filter:</span>
        </div>
        <div class="flex gap-2 flex-wrap">
            <!-- All Endpoints Pill (Equal Width, Two-Line) -->
            <div
                class="endpoint-pill-equal flex items-center gap-3 rounded-lg px-4 py-2.5 cursor-pointer transition-all border"
                :class="selectedEndpoint === null ? 'bg-blue-600 border-blue-500' : 'bg-slate-800 border-slate-700 hover:bg-slate-750'"
                @click="clearEndpointFilter()">
                <span class="text-xl flex-shrink-0 leading-none">üåê</span>
                <div class="flex flex-col justify-center min-w-0 flex-1">
                    <span class="font-semibold text-white text-sm leading-snug">All Endpoints</span>
                    <span class="text-slate-300 text-xs leading-snug">Global View</span>
                </div>
            </div>

            <!-- Endpoint Pills (Equal Width, Two-Line) -->
            <template x-for="conn in vpnStatus.connections" :key="conn.region_id">
                <div
                    class="endpoint-pill-equal flex items-center gap-3 rounded-lg px-4 py-2.5 cursor-pointer transition-all border"
                    :class="selectedEndpoint === conn.region_id ? 'bg-blue-600 border-blue-500' : 'bg-slate-800 border-slate-700 hover:bg-slate-750'"
                    @click="selectEndpointFilter(conn.region_id); fetchEndpointMetadata(conn.endpoint_ip)">

                    <!-- Country flag (from ipapi.co) -->
                    <span class="text-xl flex-shrink-0 leading-none" x-text="getCountryFlagEmoji(endpointMetadata[conn.endpoint_ip]?.countryCode || '??')"></span>

                    <!-- Two-line text layout -->
                    <div class="flex flex-col justify-center min-w-0 flex-1">
                        <!-- Line 1: Endpoint name (bold) -->
                        <span class="font-semibold text-white text-sm leading-snug truncate" x-text="conn.region_name"></span>
                        <!-- Line 2: IP address -->
                        <span class="text-slate-300 text-xs font-mono leading-snug truncate" x-text="conn.endpoint_ip || '...'"></span>
                    </div>
                </div>
            </template>
        </div>
    </div>

    <!-- Main Content: Split View (Graph + Table) -->
    <main class="px-6 py-4" style="height: calc(100vh - 140px);">
        <div class="flex space-x-4 h-full">
            <!-- LEFT: Geographic Topology (expandable) -->
            <div class="topology-container flex-shrink-0 relative" :class="mapExpanded ? 'w-[85%]' : 'w-3/5'">
                <div class="bg-slate-900 rounded-lg border border-slate-800 p-4 h-full flex flex-col">
                    <div class="flex items-center justify-between mb-3">
                        <h2 class="text-lg font-semibold text-white">Network Topology</h2>

                        <!-- Expand/Collapse Toggle -->
                        <button
                            @click="mapExpanded = !mapExpanded"
                            class="expand-toggle"
                            :title="mapExpanded ? 'Collapse map' : 'Expand map'">
                            <svg x-show="!mapExpanded" class="w-5 h-5 text-slate-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path>
                            </svg>
                            <svg x-show="mapExpanded" class="w-5 h-5 text-slate-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                    <div id="topology-graph" class="flex-1 min-h-0" style="position: relative;">
                        <!-- Canvas overlay for animated dashes (GPU-friendly) -->
                        <canvas id="routes-overlay" style="position: absolute; top: 0; left: 0; pointer-events: none; z-index: 10;"></canvas>
                    </div>
                </div>
            </div>

            <!-- RIGHT: Metrics + Device Routing (stacked) -->
            <div class="table-container flex-shrink-0 flex flex-col space-y-4" :class="mapExpanded ? 'w-[15%]' : 'w-2/5'">
                <!-- Endpoint Metrics Card (conditionally shown) -->
                <div x-show="selectedEndpoint !== null" x-cloak class="bg-slate-900 rounded-lg border border-slate-800 p-4">
                    <!-- Header -->
                    <div class="flex items-center justify-between mb-4">
                        <h2 class="text-lg font-semibold text-white">Endpoint Metrics</h2>
                        <span class="text-xs text-slate-400" x-text="getSelectedEndpointName()"></span>
                    </div>


                    <!-- Enhanced Metrics Summary with Current + Average -->
                    <div class="grid grid-cols-2 gap-3 mb-4">
                        <div class="bg-slate-800 rounded p-3 border border-slate-700">
                            <div class="text-xs text-slate-400 mb-1 font-medium">Download</div>
                            <div class="text-base font-bold text-green-400" x-text="getCurrentDownloadRate()"></div>
                            <div class="text-xs text-slate-500 mt-1">
                                <span class="text-slate-400">avg</span> <span x-text="getAverageDownloadRate()"></span>
                            </div>
                        </div>
                        <div class="bg-slate-800 rounded p-3 border border-slate-700">
                            <div class="text-xs text-slate-400 mb-1 font-medium">Upload</div>
                            <div class="text-base font-bold text-blue-400" x-text="getCurrentUploadRate()"></div>
                            <div class="text-xs text-slate-500 mt-1">
                                <span class="text-slate-400">avg</span> <span x-text="getAverageUploadRate()"></span>
                            </div>
                        </div>
                    </div>

                    <!-- Throughput Graph - Ultra-lightweight Canvas -->
                    <div class="mb-4">
                        <h3 class="text-sm font-medium text-slate-300 mb-2">Throughput</h3>
                        <div class="bg-slate-800 rounded p-2 border border-slate-700 relative" style="height: 180px;">
                            <canvas id="throughput-canvas"
                                    width="600"
                                    height="164"
                                    style="width: 100%; height: 164px; display: block;"
                                    x-show="hasMetricsData()"></canvas>
                            <!-- Empty State -->
                            <div x-show="!hasMetricsData()" class="flex items-center justify-center h-full">
                                <div class="text-center">
                                    <svg class="w-12 h-12 mx-auto mb-2 text-slate-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 12l3-3 3 3 4-4M8 21l4-4 4 4M3 4h18M4 4h16v12a1 1 0 01-1 1H5a1 1 0 01-1-1V4z"></path>
                                    </svg>
                                    <p class="text-xs text-slate-500">No recent metrics</p>
                                    <p class="text-xs text-slate-600 mt-1">for <span x-text="getSelectedEndpointName()"></span></p>
                                </div>
                            </div>
                        </div>
                        <!-- Custom Legend -->
                        <div class="flex gap-5 mt-3 px-2">
                            <div class="flex items-center gap-2">
                                <span class="inline-block w-3 h-0.5 bg-green-500 rounded-sm"></span>
                                <span class="text-xs font-medium text-slate-400 tracking-wide">Download</span>
                            </div>
                            <div class="flex items-center gap-2">
                                <span class="inline-block w-3 h-0.5 bg-blue-500 rounded-sm"></span>
                                <span class="text-xs font-medium text-slate-400 tracking-wide">Upload</span>
                            </div>
                        </div>
                    </div>

                </div>

                <!-- Device Routing Card -->
                <div class="bg-slate-900 rounded-lg border border-slate-800 p-4 flex-1 min-h-0 flex flex-col">
                    <div class="flex items-center justify-between mb-3">
                        <h2 class="text-lg font-semibold text-white" x-show="!mapExpanded">Device Routing</h2>
                        <h2 class="text-sm font-semibold text-white" x-show="mapExpanded">Devices</h2>
                        <span class="text-sm text-slate-400"><span x-text="filteredDevices.length"></span><span x-show="!mapExpanded"> / <span x-text="devices.length"></span></span></span>
                    </div>

                    <!-- Scrollable table container -->
                    <div class="device-table-container flex-1 min-h-0 overflow-y-auto">
                        <table class="device-table w-full" x-show="!mapExpanded">
                            <thead class="sticky top-0 bg-slate-800 text-slate-300 text-xs uppercase">
                                <tr>
                                    <th class="px-3 py-2 text-left">Device</th>
                                    <th class="px-3 py-2 text-left">IP</th>
                                    <th class="px-3 py-2 text-left">Region</th>
                                    <th class="px-3 py-2 text-center">Route</th>
                                </tr>
                            </thead>
                            <tbody>
                                <template x-for="device in filteredDevices" :key="device.id">
                                    <tr
                                        class="device-row border-b border-slate-800"
                                        :class="selectedDevice === device.id ? 'selected' : ''"
                                        @click="selectDevice(device.id)">
                                        <td class="px-3 py-2">
                                            <div class="flex items-center space-x-2">
                                                <div :class="device.online ? 'bg-green-500' : 'bg-slate-500'" class="w-2 h-2 rounded-full"></div>
                                                <span class="font-medium text-white truncate" x-text="device.hostname"></span>
                                            </div>
                                        </td>
                                        <td class="px-3 py-2 text-slate-400 text-sm" x-text="device.ip_addresses[0]"></td>
                                        <td class="px-3 py-2" x-data="{
                                            open: false,
                                            search: '',
                                            deviceId: device.id,
                                            get filteredRegions() {
                                                if (!this.search) return regions;
                                                const s = this.search.toLowerCase();
                                                return regions.filter(r =>
                                                    r.name.toLowerCase().includes(s) ||
                                                    r.country.toLowerCase().includes(s) ||
                                                    r.id.toLowerCase().includes(s)
                                                );
                                            },
                                            selectRegion(regionId) {
                                                setDeviceRegion(this.deviceId, regionId);
                                                this.open = false;
                                                this.search = '';
                                            }
                                        }">
                                            <div class="relative" @click.away="open = false">
                                                <!-- Dropdown trigger -->
                                                <button
                                                    @click.stop="open = !open"
                                                    class="bg-slate-800 border border-slate-700 rounded px-2 py-1 text-sm text-white w-full text-left flex items-center justify-between"
                                                    type="button">
                                                    <span x-text="device.region_id ? (regions.find(r => r.id === device.region_id)?.name || 'Unknown') : 'No VPN'"></span>
                                                    <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                                    </svg>
                                                </button>

                                                <!-- Dropdown menu -->
                                                <div
                                                    x-show="open"
                                                    x-cloak
                                                    class="absolute z-50 mt-1 w-64 bg-slate-800 border border-slate-700 rounded shadow-xl max-h-80 overflow-hidden"
                                                    style="display: none;">
                                                    <!-- Search input -->
                                                    <div class="p-2 border-b border-slate-700">
                                                        <input
                                                            x-model="search"
                                                            @click.stop
                                                            type="text"
                                                            placeholder="Search regions..."
                                                            class="w-full bg-slate-900 border border-slate-600 rounded px-2 py-1 text-sm text-white focus:outline-none focus:border-blue-500">
                                                    </div>

                                                    <!-- Options list -->
                                                    <div class="overflow-y-auto max-h-64">
                                                        <!-- No VPN option -->
                                                        <div
                                                            @click.stop="selectRegion('')"
                                                            class="px-3 py-2 text-sm text-white hover:bg-slate-700 cursor-pointer"
                                                            :class="!device.region_id ? 'bg-slate-700' : ''">
                                                            No VPN
                                                        </div>

                                                        <!-- Region options -->
                                                        <template x-for="region in filteredRegions" :key="region.id">
                                                            <div
                                                                @click.stop="selectRegion(region.id)"
                                                                class="px-3 py-2 text-sm text-white hover:bg-slate-700 cursor-pointer"
                                                                :class="device.region_id === region.id ? 'bg-slate-700' : ''">
                                                                <div class="font-medium" x-text="region.name"></div>
                                                                <div class="text-xs text-slate-400" x-text="region.country"></div>
                                                            </div>
                                                        </template>

                                                        <!-- No results -->
                                                        <div x-show="search && filteredRegions.length === 0" class="px-3 py-2 text-sm text-slate-400 italic">
                                                            No regions found
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </td>
                                        <td class="px-3 py-2 text-center">
                                            <button
                                                @click.stop="toggleDeviceRouting(device.id)"
                                                :disabled="!device.region_id || isDeviceActionInFlight(device.id)"
                                                class="w-8 h-8 rounded-full transition-colors relative"
                                                :class="{
                                                    'bg-red-600 hover:bg-red-700': device.routing_enabled && !isDeviceActionInFlight(device.id),
                                                    'bg-green-600 hover:bg-green-700': !device.routing_enabled && device.region_id && !isDeviceActionInFlight(device.id),
                                                    'bg-slate-700 cursor-not-allowed': !device.region_id || isDeviceActionInFlight(device.id),
                                                    'opacity-50': isDeviceActionInFlight(device.id)
                                                }"
                                                :title="isDeviceActionInFlight(device.id) ? (device.routing_enabled ? 'Stopping...' : 'Starting...') : (device.routing_enabled ? 'Stop routing' : (device.region_id ? 'Start routing' : 'Select region first'))">
                                                <!-- Spinner (when in-flight) -->
                                                <svg x-show="isDeviceActionInFlight(device.id)" class="animate-spin w-4 h-4 mx-auto text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                                </svg>
                                                <!-- Play Icon -->
                                                <svg x-show="!device.routing_enabled && !isDeviceActionInFlight(device.id)" class="w-4 h-4 mx-auto" fill="currentColor" viewBox="0 0 24 24">
                                                    <path d="M8 5v14l11-7z"/>
                                                </svg>
                                                <!-- Stop Icon -->
                                                <svg x-show="device.routing_enabled && !isDeviceActionInFlight(device.id)" class="w-4 h-4 mx-auto" fill="currentColor" viewBox="0 0 24 24">
                                                    <path d="M6 6h12v12H6z"/>
                                                </svg>
                                            </button>
                                        </td>
                                    </tr>
                                </template>
                            </tbody>
                        </table>

                        <!-- Compact view when expanded -->
                        <div x-show="mapExpanded" class="space-y-2">
                            <template x-for="device in filteredDevices" :key="device.id">
                                <div
                                    class="p-2 bg-slate-800 rounded border border-slate-700 cursor-pointer hover:bg-slate-750"
                                    :class="selectedDevice === device.id ? 'bg-slate-700' : ''"
                                    @click="selectDevice(device.id)">
                                    <div class="flex items-center space-x-2">
                                        <div :class="device.online ? 'bg-green-500' : 'bg-slate-500'" class="w-2 h-2 rounded-full flex-shrink-0"></div>
                                        <span class="text-xs font-medium text-white truncate" x-text="device.hostname"></span>
                                    </div>
                                </div>
                            </template>
                        </div>

                        <div x-show="filteredDevices.length === 0" class="text-center py-8 text-slate-500 text-sm">
                            No devices found
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // Geographic coordinates for PIA regions (CORRECTED)
        const REGION_COORDINATES = {
            'sg': { lat: 1.3521, lng: 103.8198, name: 'Singapore' },
            'singapore': { lat: 1.3521, lng: 103.8198, name: 'Singapore' },
            'kh': { lat: 11.5564, lng: 104.9282, name: 'Cambodia' },
            'cambodia': { lat: 11.5564, lng: 104.9282, name: 'Cambodia' },
            'alaska': { lat: 61.2181, lng: -149.9003, name: 'US Alaska' },
            'melbourne': { lat: -37.8136, lng: 144.9631, name: 'AU Melbourne' },
            'sydney': { lat: -33.8688, lng: 151.2093, name: 'AU Sydney' },
            'perth': { lat: -31.9505, lng: 115.8605, name: 'AU Perth' },
            'japan': { lat: 35.6762, lng: 139.6503, name: 'Japan' },
            'tokyo': { lat: 35.6762, lng: 139.6503, name: 'Japan' },
            'hong': { lat: 22.3193, lng: 114.1694, name: 'Hong Kong' },
            'india': { lat: 19.0760, lng: 72.8777, name: 'India' },
            'mumbai': { lat: 19.0760, lng: 72.8777, name: 'India' },
            'zealand': { lat: -36.8485, lng: 174.7633, name: 'New Zealand' },
            'auckland': { lat: -36.8485, lng: 174.7633, name: 'New Zealand' },
            'london': { lat: 51.5074, lng: -0.1278, name: 'UK London' },
            'uk': { lat: 51.5074, lng: -0.1278, name: 'UK' },
            'germany': { lat: 52.5200, lng: 13.4050, name: 'Germany' },
            'berlin': { lat: 52.5200, lng: 13.4050, name: 'Germany' },
            'france': { lat: 48.8566, lng: 2.3522, name: 'France' },
            'paris': { lat: 48.8566, lng: 2.3522, name: 'France' },
            'netherlands': { lat: 52.3676, lng: 4.9041, name: 'Netherlands' },
            'amsterdam': { lat: 52.3676, lng: 4.9041, name: 'Netherlands' },
            'california': { lat: 37.7749, lng: -122.4194, name: 'US California' },
            'newyork': { lat: 40.7128, lng: -74.0060, name: 'US New York' },
            'texas': { lat: 29.7604, lng: -95.3698, name: 'US Texas' },
            'houston': { lat: 29.7604, lng: -95.3698, name: 'US Texas' },
            'canada': { lat: 43.6532, lng: -79.3832, name: 'Canada' },
            'toronto': { lat: 43.6532, lng: -79.3832, name: 'Canada' },
            'brazil': { lat: -23.5505, lng: -46.6333, name: 'Brazil' },
            'paulo': { lat: -23.5505, lng: -46.6333, name: 'Brazil' },
            'africa': { lat: -33.9249, lng: 18.4241, name: 'South Africa' },
            'capetown': { lat: -33.9249, lng: 18.4241, name: 'South Africa' }
        };

        function app() {
            return {
                loading: false,
                vpnStatus: { active_count: 0, connections: [] },
                tailscaleStatus: { running: false, exit_node_enabled: false, hostname: null },
                systemHealth: { healthy: false, messages: [] },
                regions: [],
                devices: [],
                selectedEndpoint: null,  // null = "All Endpoints"
                selectedDevice: null,
                mapExpanded: false,
                pollInterval: null,
                networkGraph: null,
                resizeObserver: null,
                endpointMetadata: {},  // Cache for endpoint IP/country data from ipapi.co
                deviceStates: {},  // Track device routing states: {deviceId: 'running'|'stopping'|'stopped'|'error'}
                inFlightRequests: new Set(),  // Track in-flight API requests to prevent duplicates

                // WebSocket for real-time metrics
                websocket: null,
                metricsData: {},  // { interface: { timestamps: [], rx: [], tx: [], rawRx: [], rawTx: [] } }

                // Canvas route animation state (GPU-friendly)
                routesCanvas: null,
                routesCtx: null,
                animatedRoutes: [],  // [{ id, samples: [{x,y}...], color, isActive, zIndex }]
                animationTime: 0,
                routeAnimationFrameId: null,

                get filteredDevices() {
                    if (this.selectedEndpoint === null) return this.devices;
                    return this.devices.filter(d => d.region_id === this.selectedEndpoint && d.routing_enabled);
                },

                getDeviceState(deviceId) {
                    if (this.deviceStates[deviceId]) return this.deviceStates[deviceId];
                    const device = this.devices.find(d => d.id === deviceId);
                    return device?.routing_enabled ? 'running' : 'stopped';
                },

                isDeviceActionInFlight(deviceId) {
                    return this.inFlightRequests.has(deviceId);
                },

                async init() {
                    await this.loadRegions();
                    await this.refreshStatus();
                    await this.initTopologyGraph();

                    // Start WebSocket for real-time metrics
                    this.connectMetricsWebSocket();

                    // Start GPU-friendly canvas animation for dashed routes
                    this.initRoutesCanvas();
                    this.startCanvasAnimation();

                    // Poll status every 5 seconds
                    this.pollInterval = setInterval(() => {
                        this.refreshStatus();
                    }, 5000);

                    // Use ResizeObserver for auto-resize
                    const container = document.getElementById('topology-graph');
                    if (container) {
                        this.resizeObserver = new ResizeObserver(() => {
                            this.resizeTopologyGraph();
                        });
                        this.resizeObserver.observe(container);
                    }
                },

                startDashAnimation() {
                    const animate = () => {
                        this.dashAnimationFrame++;

                        // Update every 4 frames (~15fps at 60fps screen refresh)
                        if (this.dashAnimationFrame % 4 === 0) {
                            this.dashOffset -= 1.5;  // Smooth movement

                            // Update all VPN route paths
                            const vpnPaths = document.querySelectorAll('.network-link-vpn');
                            vpnPaths.forEach(path => {
                                path.style.strokeDashoffset = this.dashOffset + 'px';
                            });
                        }

                        this.animationFrameId = requestAnimationFrame(animate);
                    };

                    this.animationFrameId = requestAnimationFrame(animate);
                },

                stopDashAnimation() {
                    if (this.animationFrameId) {
                        cancelAnimationFrame(this.animationFrameId);
                        this.animationFrameId = null;
                    }
                },

                // ========================================
                // GPU-FRIENDLY CANVAS ROUTE ANIMATION
                // ========================================

                initRoutesCanvas() {
                    this.routesCanvas = document.getElementById('routes-overlay');
                    if (!this.routesCanvas) return;

                    this.routesCtx = this.routesCanvas.getContext('2d', {
                        alpha: true,
                        desynchronized: true  // Hint for better performance
                    });

                    // Sync canvas size with container
                    this.resizeRoutesCanvas();
                },

                resizeRoutesCanvas() {
                    if (!this.routesCanvas || !this.networkGraph) return;

                    const { width, height } = this.networkGraph;
                    const dpr = window.devicePixelRatio || 1;

                    // Set actual canvas size (accounting for device pixel ratio)
                    this.routesCanvas.width = width * dpr;
                    this.routesCanvas.height = height * dpr;

                    // Set display size
                    this.routesCanvas.style.width = width + 'px';
                    this.routesCanvas.style.height = height + 'px';

                    // Scale context for device pixel ratio
                    this.routesCtx.scale(dpr, dpr);

                    // Rebuild routes after resize
                    this.buildRoutesFromSvg();
                },

                buildRoutesFromSvg() {
                    if (!this.networkGraph) return;

                    this.animatedRoutes = [];

                    // Get all VPN route paths from SVG
                    const vpnPaths = document.querySelectorAll('.network-link-vpn');

                    vpnPaths.forEach((path, index) => {
                        const totalLength = path.getTotalLength();
                        const samples = [];

                        // Trim endpoints to avoid drawing on dots (14px node radius + 2px margin)
                        const endpointTrim = 16;
                        const trimmedLength = Math.max(0, totalLength - (2 * endpointTrim));

                        if (trimmedLength <= 0) return; // Skip very short paths

                        // Sample points along path (1 point every 5px)
                        const sampleInterval = 5;
                        const numSamples = Math.ceil(trimmedLength / sampleInterval);

                        for (let i = 0; i <= numSamples; i++) {
                            const distance = endpointTrim + (i / numSamples) * trimmedLength;
                            const point = path.getPointAtLength(distance);
                            samples.push({ x: point.x, y: point.y });
                        }

                        // Determine route state
                        const isDimmed = path.classList.contains('dimmed');
                        const isHighlighted = path.classList.contains('highlighted');

                        // Get color from computed style or default
                        const computedStyle = getComputedStyle(path);
                        const strokeColor = computedStyle.stroke;

                        // Convert SVG color to canvas-friendly format
                        let color = '#60a5fa';  // Default blue
                        if (isHighlighted) {
                            color = '#fbbf24';  // Yellow
                        } else if (isDimmed) {
                            color = '#475569';  // Gray
                        }

                        this.animatedRoutes.push({
                            id: `route-${index}`,
                            samples,
                            color,
                            isActive: !isDimmed,
                            zIndex: index,  // DOM order
                            speed: 0.006,  // Animation speed (sweet spot)
                            totalLength: trimmedLength  // Store for dash length calculation
                        });
                    });
                },

                startCanvasAnimation() {
                    if (this.routeAnimationFrameId) return;  // Already running

                    let lastTime = performance.now();

                    const animate = (currentTime) => {
                        const deltaTime = currentTime - lastTime;
                        lastTime = currentTime;

                        this.animationTime += deltaTime;

                        this.renderAnimatedRoutes();

                        this.routeAnimationFrameId = requestAnimationFrame(animate);
                    };

                    this.routeAnimationFrameId = requestAnimationFrame(animate);
                },

                stopCanvasAnimation() {
                    if (this.routeAnimationFrameId) {
                        cancelAnimationFrame(this.routeAnimationFrameId);
                        this.routeAnimationFrameId = null;
                    }
                },

                renderAnimatedRoutes() {
                    if (!this.routesCtx || !this.routesCanvas) return;

                    const ctx = this.routesCtx;
                    const { width, height } = this.networkGraph || { width: 800, height: 600 };

                    // Clear canvas
                    ctx.clearRect(0, 0, width, height);

                    // Sort routes by zIndex (background first, foreground last)
                    const sortedRoutes = [...this.animatedRoutes].sort((a, b) => a.zIndex - b.zIndex);

                    // Draw each route
                    sortedRoutes.forEach(route => {
                        const pts = route.samples;
                        const len = pts.length;
                        if (len < 2) return;

                        // Set opacity based on active state (reduced brightness)
                        ctx.globalAlpha = route.isActive ? 0.5 : 0.2;

                        // Fixed-length dashes covering 50% of path
                        const fixedDashLengthPx = 10;  // Smaller 10px dashes (was 20px)
                        const sampleInterval = 5;  // Same as sampling interval
                        const dashLengthSamples = Math.ceil(fixedDashLengthPx / sampleInterval);

                        // Calculate dash count to cover 50% of path (automatically doubles with smaller dashes)
                        const totalDashLength = route.totalLength * 0.5;  // 50% coverage
                        const dashCount = Math.max(1, Math.floor(totalDashLength / fixedDashLengthPx));

                        for (let d = 0; d < dashCount; d++) {
                            // Calculate phase offset
                            const offset = Math.floor((this.animationTime * route.speed + d * len / dashCount) % len);
                            const startIndex = Math.min(offset, len - 1);
                            const endIndex = Math.min((offset + dashLengthSamples) % len, len - 1);

                            // Safety check - ensure indices are valid
                            if (startIndex >= len || !pts[startIndex]) continue;

                            ctx.beginPath();
                            ctx.strokeStyle = route.color;
                            ctx.lineWidth = 1.5;  // Thinner lines for less GPU work
                            ctx.lineCap = 'round';
                            ctx.lineJoin = 'round';

                            // Draw dash segment
                            if (endIndex > startIndex) {
                                // Normal case - no wrap
                                ctx.moveTo(pts[startIndex].x, pts[startIndex].y);
                                for (let i = startIndex + 1; i <= endIndex && i < len; i++) {
                                    if (pts[i]) {
                                        ctx.lineTo(pts[i].x, pts[i].y);
                                    }
                                }
                            } else {
                                // Wrapped around end of array
                                ctx.moveTo(pts[startIndex].x, pts[startIndex].y);
                                for (let i = startIndex + 1; i < len; i++) {
                                    if (pts[i]) {
                                        ctx.lineTo(pts[i].x, pts[i].y);
                                    }
                                }
                                // Continue from beginning
                                if (endIndex > 0 && pts[0]) {
                                    ctx.moveTo(pts[0].x, pts[0].y);
                                    for (let i = 1; i <= endIndex && i < len; i++) {
                                        if (pts[i]) {
                                            ctx.lineTo(pts[i].x, pts[i].y);
                                        }
                                    }
                                }
                            }

                            ctx.stroke();
                        }
                    });

                    // Reset alpha
                    ctx.globalAlpha = 1.0;
                },

                async loadRegions() {
                    try {
                        const response = await fetch('/api/settings/regions');
                        const data = await response.json();
                        this.regions = data.regions;
                    } catch (error) {
                        console.error('Failed to load regions:', error);
                    }
                },

                async refreshStatus() {
                    // Store previous state to detect actual changes
                    const prevConnectionCount = this.vpnStatus.connections?.length || 0;
                    const prevDeviceCount = this.devices?.length || 0;

                    // Store previous routing states
                    const prevRoutingStates = new Set(
                        this.devices?.filter(d => d.routing_enabled).map(d => d.id) || []
                    );

                    await Promise.all([
                        this.loadVPNStatus(),
                        this.loadTailscaleStatus(),
                        this.loadSystemHealth(),
                        this.loadDevices()
                    ]);

                    // Check for topology changes
                    const connectionCountChanged = (this.vpnStatus.connections?.length || 0) !== prevConnectionCount;
                    const deviceCountChanged = (this.devices?.length || 0) !== prevDeviceCount;

                    // Check if any device routing state changed
                    const currentRoutingStates = new Set(
                        this.devices?.filter(d => d.routing_enabled).map(d => d.id) || []
                    );
                    const routingStateChanged =
                        prevRoutingStates.size !== currentRoutingStates.size ||
                        [...prevRoutingStates].some(id => !currentRoutingStates.has(id)) ||
                        [...currentRoutingStates].some(id => !prevRoutingStates.has(id));

                    if (connectionCountChanged || deviceCountChanged || routingStateChanged) {
                        this.$nextTick(() => {
                            this.updateTopologyGraph();
                        });
                    }
                },

                async loadVPNStatus() {
                    try {
                        const response = await fetch('/api/status/vpn');
                        this.vpnStatus = await response.json();

                        // AWAIT all endpoint metadata fetching before rendering
                        if (this.vpnStatus.connections) {
                            const metadataPromises = this.vpnStatus.connections
                                .filter(conn => conn.endpoint_ip)
                                .map(conn => this.fetchEndpointMetadata(conn.endpoint_ip, conn.region_id));

                            await Promise.all(metadataPromises);
                            console.log('‚úì All endpoint metadata loaded');
                        }
                    } catch (error) {
                        console.error('Failed to load VPN status:', error);
                        this.vpnStatus = { active_count: 0, connections: [] };
                    }
                },

                async loadTailscaleStatus() {
                    try {
                        const response = await fetch('/api/status/tailscale');
                        this.tailscaleStatus = await response.json();
                    } catch (error) {
                        console.error('Failed to load Tailscale status:', error);
                    }
                },

                async loadSystemHealth() {
                    try {
                        const response = await fetch('/api/status/health');
                        this.systemHealth = await response.json();
                    } catch (error) {
                        console.error('Failed to load system health:', error);
                    }
                },

                async loadDevices() {
                    try {
                        const response = await fetch('/api/devices');
                        const data = await response.json();
                        this.devices = data.devices;
                    } catch (error) {
                        console.error('Failed to load devices:', error);
                    }
                },

                // Fallback locations when ipapi.co fails (by region ID for specificity)
                getFallbackLocationByRegion(regionId, countryCode) {
                    const id = regionId ? regionId.toLowerCase() : '';

                    // Australia - specific cities
                    if (id.includes('perth')) return { lat: -31.9505, lon: 115.8605, city: 'Perth', countryName: 'Australia', countryCode: 'AU' };
                    if (id.includes('brisbane')) return { lat: -27.4698, lon: 153.0251, city: 'Brisbane', countryName: 'Australia', countryCode: 'AU' };
                    if (id.includes('melbourne')) return { lat: -37.8136, lon: 144.9631, city: 'Melbourne', countryName: 'Australia', countryCode: 'AU' };
                    if (id.includes('sydney')) return { lat: -33.8688, lon: 151.2093, city: 'Sydney', countryName: 'Australia', countryCode: 'AU' };

                    // Country-level fallbacks
                    const fallbacks = {
                        'AU': { lat: -37.8136, lon: 144.9631, city: 'Melbourne', countryName: 'Australia' },
                        'JP': { lat: 35.6762, lon: 139.6503, city: 'Tokyo', countryName: 'Japan' },
                        'SG': { lat: 1.3521, lon: 103.8198, city: 'Singapore', countryName: 'Singapore' },
                        'KH': { lat: 11.5564, lon: 104.9282, city: 'Phnom Penh', countryName: 'Cambodia' },
                        'US': { lat: 61.2181, lon: -149.9003, city: 'Anchorage', countryName: 'United States' },
                        'MC': { lat: 43.7384, lon: 7.4246, city: 'Monaco', countryName: 'Monaco' },
                        'NZ': { lat: -36.8485, lon: 174.7633, city: 'Auckland', countryName: 'New Zealand' },
                        'HK': { lat: 22.3193, lon: 114.1694, city: 'Hong Kong', countryName: 'Hong Kong' },
                        'IN': { lat: 19.0760, lon: 72.8777, city: 'Mumbai', countryName: 'India' }
                    };
                    const fallback = fallbacks[countryCode] || { lat: 0, lon: 0, city: 'Unknown', countryName: 'Unknown' };
                    return { ...fallback, countryCode };
                },

                // Country center coordinates for grouping
                getCountryCenter(countryCode) {
                    const centers = {
                        'AU': { lat: -25.2744, lon: 133.7751 },  // Australia (geographic center)
                        'US': { lat: 39.8283, lon: -98.5795 },   // United States (geographic center)
                        'JP': { lat: 36.2048, lon: 138.2529 },   // Japan (geographic center)
                        'SG': { lat: 1.3521, lon: 103.8198 },    // Singapore (city-state)
                        'KH': { lat: 12.5657, lon: 104.9910 },   // Cambodia (geographic center)
                        'MC': { lat: 43.7384, lon: 7.4246 },     // Monaco (city-state)
                        'NZ': { lat: -40.9006, lon: 174.8860 },  // New Zealand (geographic center)
                        'HK': { lat: 22.3193, lon: 114.1694 },   // Hong Kong (city-state)
                        'IN': { lat: 20.5937, lon: 78.9629 }     // India (geographic center)
                    };
                    return centers[countryCode] || null;
                },

                // Group endpoints by country (single endpoint ‚Üí city, multiple ‚Üí country center)
                groupEndpointsByLocation(connections) {
                    const groups = [];
                    const processed = new Set();

                    // First, group by country code
                    const byCountry = {};
                    connections.forEach(conn => {
                        const metadata = this.endpointMetadata[conn.endpoint_ip];
                        if (!metadata || typeof metadata.lat !== 'number') return;

                        // Exception: Treat US Alaska separately from other US regions
                        const groupKey = (metadata.countryCode === 'US' && conn.region_id.toLowerCase().includes('alaska'))
                            ? 'US-ALASKA'
                            : metadata.countryCode;

                        if (!byCountry[groupKey]) {
                            byCountry[groupKey] = [];
                        }
                        byCountry[groupKey].push(conn);
                    });

                    // Create groups based on country count
                    Object.entries(byCountry).forEach(([groupKey, endpoints]) => {
                        if (endpoints.length === 1) {
                            // Single endpoint in country ‚Üí use city location
                            const conn = endpoints[0];
                            const metadata = this.endpointMetadata[conn.endpoint_ip];

                            groups.push({
                                lat: metadata.lat,
                                lon: metadata.lon,
                                city: metadata.city,
                                countryCode: metadata.countryCode,
                                countryName: metadata.countryName,
                                endpoints: endpoints,
                                isMulti: false,
                                isCityLevel: true
                            });
                        } else {
                            // Multiple endpoints in country ‚Üí use country center
                            const firstMetadata = this.endpointMetadata[endpoints[0].endpoint_ip];
                            const countryCode = groupKey === 'US-ALASKA' ? 'US' : groupKey;
                            const center = this.getCountryCenter(countryCode);

                            if (center) {
                                // Collect all unique cities
                                const cities = [...new Set(endpoints.map(e => {
                                    const m = this.endpointMetadata[e.endpoint_ip];
                                    return m?.city || 'Unknown';
                                }).filter(c => c !== 'Unknown'))];

                                groups.push({
                                    lat: center.lat,
                                    lon: center.lon,
                                    city: null,  // No single city
                                    cities: cities,  // List of cities
                                    countryCode: firstMetadata.countryCode,
                                    countryName: firstMetadata.countryName,
                                    endpoints: endpoints,
                                    isMulti: true,
                                    isCityLevel: false
                                });
                            } else {
                                // Fallback: use first endpoint's location
                                const metadata = this.endpointMetadata[endpoints[0].endpoint_ip];
                                groups.push({
                                    lat: metadata.lat,
                                    lon: metadata.lon,
                                    city: metadata.city,
                                    countryCode: metadata.countryCode,
                                    countryName: metadata.countryName,
                                    endpoints: endpoints,
                                    isMulti: true,
                                    isCityLevel: false
                                });
                            }
                        }
                    });

                    return groups;
                },

                // Guess country code from region ID
                guessCountryFromRegion(regionId) {
                    const id = regionId.toLowerCase();
                    if (id.includes('aus') || id.includes('melbourne') || id.includes('sydney') || id.includes('perth')) return 'AU';
                    if (id.includes('japan') || id.includes('jp') || id.includes('tokyo')) return 'JP';
                    if (id.includes('singapore') || id === 'sg') return 'SG';
                    if (id.includes('cambodia') || id === 'kh') return 'KH';
                    if (id.includes('alaska') || id.includes('us')) return 'US';
                    if (id.includes('monaco') || id === 'mc') return 'MC';
                    if (id.includes('hong') || id === 'hk') return 'HK';
                    if (id.includes('india') || id.includes('mumbai')) return 'IN';
                    if (id.includes('zealand') || id === 'nz') return 'NZ';
                    return null;
                },

                async fetchEndpointMetadata(endpointIP, regionId = null) {
                    // Check cache first
                    if (this.endpointMetadata[endpointIP]) {
                        return this.endpointMetadata[endpointIP];
                    }

                    try {
                        const response = await fetch(`https://ipapi.co/${endpointIP}/json/`);
                        const data = await response.json();

                        // Validate we got valid data
                        if (!data.country_code || typeof data.latitude !== 'number' || typeof data.longitude !== 'number') {
                            throw new Error('Invalid response from ipapi.co');
                        }

                        const metadata = {
                            ip: endpointIP,
                            countryCode: data.country_code,
                            countryName: data.country_name || 'Unknown',
                            city: data.city || null,
                            lat: data.latitude,
                            lon: data.longitude,
                            locationUnknown: false
                        };

                        // Cache the result
                        this.endpointMetadata[endpointIP] = metadata;
                        console.log(`‚úì Resolved ${endpointIP}: ${metadata.countryCode} ${metadata.city || ''} (${metadata.lat}, ${metadata.lon})`);
                        return metadata;
                    } catch (error) {
                        console.warn(`‚ö† Failed to fetch metadata for ${endpointIP}, using fallback:`, error);

                        // Try to guess country from region ID
                        const guessedCountry = regionId ? this.guessCountryFromRegion(regionId) : null;
                        const fallbackCountry = guessedCountry || 'AU'; // Default to Australia if can't guess
                        const fallback = this.getFallbackLocationByRegion(regionId, fallbackCountry);

                        const metadata = {
                            ip: endpointIP,
                            countryCode: fallback.countryCode,
                            countryName: fallback.countryName,
                            city: fallback.city,
                            lat: fallback.lat,
                            lon: fallback.lon,
                            locationUnknown: true
                        };

                        this.endpointMetadata[endpointIP] = metadata;
                        console.log(`‚ö† Using fallback for ${endpointIP} (${regionId}): ${metadata.countryCode} ${metadata.city} (${metadata.lat}, ${metadata.lon})`);
                        return metadata;
                    }
                },

                getCountryFlagEmoji(countryCode) {
                    if (!countryCode || countryCode === '??') return 'üåê';

                    // Convert ISO country code to flag emoji
                    // Each letter mapped to regional indicator symbol (üá¶ = U+1F1E6)
                    const codePoints = countryCode
                        .toUpperCase()
                        .split('')
                        .map(char => 127397 + char.charCodeAt());
                    return String.fromCodePoint(...codePoints);
                },

                async setDeviceRegion(deviceId, regionId) {
                    try {
                        const response = await fetch(`/api/devices/${deviceId}/region`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ region_id: regionId || null })
                        });

                        if (!response.ok) {
                            const error = await response.json();
                            alert('Failed to set device region: ' + error.detail);
                        }

                        await this.loadDevices();
                        await this.loadVPNStatus();
                    } catch (error) {
                        alert('Failed to set device region: ' + error.message);
                    }
                },

                async toggleDeviceRouting(deviceId) {
                    // Prevent duplicate requests (debouncing)
                    if (this.inFlightRequests.has(deviceId)) {
                        console.log(`Ignoring duplicate toggle request for device ${deviceId}`);
                        return;
                    }

                    const device = this.devices.find(d => d.id === deviceId);
                    if (!device) return;

                    const currentState = this.getDeviceState(deviceId);

                    // State machine: only allow transitions from running ‚Üí stopping or stopped ‚Üí starting
                    if (currentState === 'stopping' || currentState === 'starting') {
                        console.log(`Device ${deviceId} is already ${currentState}, ignoring click`);
                        return;
                    }

                    // Determine action
                    const isCurrentlyRunning = device.routing_enabled;
                    const action = isCurrentlyRunning ? 'stop' : 'start';

                    // Optional confirmation for stop action
                    if (isCurrentlyRunning) {
                        if (!confirm(`Stop routing ${device.hostname} through VPN?`)) {
                            return;
                        }
                    }

                    try {
                        // Transition to intermediate state
                        this.deviceStates[deviceId] = isCurrentlyRunning ? 'stopping' : 'starting';
                        this.inFlightRequests.add(deviceId);

                        const response = await fetch(`/api/devices/${deviceId}/toggle`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({})
                        });

                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(error.detail || 'Unknown error');
                        }

                        // Success: transition to final state
                        this.deviceStates[deviceId] = isCurrentlyRunning ? 'stopped' : 'running';

                        // Refresh data to sync with backend
                        await this.loadDevices();
                        await this.loadVPNStatus();

                        // Clear state after refresh (let backend state be source of truth)
                        setTimeout(() => {
                            delete this.deviceStates[deviceId];
                        }, 500);

                    } catch (error) {
                        console.error(`Failed to ${action} routing for device ${deviceId}:`, error);

                        // Error state
                        this.deviceStates[deviceId] = 'error';
                        alert(`Failed to ${action} routing for ${device.hostname}: ${error.message}`);

                        // Clear error state after 3 seconds
                        setTimeout(() => {
                            delete this.deviceStates[deviceId];
                        }, 3000);

                    } finally {
                        // Always remove from in-flight set
                        this.inFlightRequests.delete(deviceId);
                    }
                },

                clearEndpointFilter() {
                    this.selectedEndpoint = null;
                    this.$nextTick(() => {
                        this.updateTopologyGraph();
                    });
                },

                selectEndpointFilter(regionId) {
                    // Clicking same endpoint does NOT clear - must click "All Endpoints"
                    this.selectedEndpoint = regionId;
                    this.$nextTick(() => {
                        this.updateTopologyGraph();
                    });
                },

                selectDevice(deviceId) {
                    if (this.selectedDevice === deviceId) {
                        this.selectedDevice = null;
                    } else {
                        this.selectedDevice = deviceId;
                    }
                    this.$nextTick(() => {
                        this.updateTopologyGraph();
                    });
                },

                // WebSocket connection for real-time metrics
                connectMetricsWebSocket() {
                    const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
                    const wsUrl = `${protocol}//${window.location.host}/api/status/ws/vpn-status`;
                    this.websocket = new WebSocket(wsUrl);

                    this.websocket.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        this.updateMetricsData(data);
                    };

                    this.websocket.onerror = (error) => {
                        console.error('WebSocket error:', error);
                        setTimeout(() => this.connectMetricsWebSocket(), 5000);
                    };

                    this.websocket.onclose = () => {
                        console.log('WebSocket closed, reconnecting...');
                        setTimeout(() => this.connectMetricsWebSocket(), 5000);
                    };
                },

                updateMetricsData(vpnStatus) {
                    const now = Date.now();

                    vpnStatus.connections.forEach(conn => {
                        const iface = conn.interface;

                        // Initialize history - EXACT COPY FROM CLASSIC VIEW
                        if (!this.metricsData[iface]) {
                            this.metricsData[iface] = {
                                timestamps: [],  // Unix timestamps in seconds
                                rx: [],
                                tx: [],
                                rawRx: [],  // Store raw rates for moving average
                                rawTx: [],  // Store raw rates for moving average
                                prevRx: conn.transfer_rx_bytes || 0,
                                prevTx: conn.transfer_tx_bytes || 0,
                                prevTime: now
                            };
                            return;
                        }

                        const history = this.metricsData[iface];
                        const timeDelta = (now - history.prevTime) / 1000; // seconds

                        // Calculate rates (bytes per second) - EXACT COPY FROM CLASSIC VIEW
                        const rxBytes = conn.transfer_rx_bytes || 0;
                        const txBytes = conn.transfer_tx_bytes || 0;

                        let rawRxRate = 0;
                        let rawTxRate = 0;

                        if (timeDelta > 0.1 && timeDelta < 30) {
                            const rxDelta = rxBytes - history.prevRx;
                            const txDelta = txBytes - history.prevTx;

                            rawRxRate = rxDelta / timeDelta;
                            rawTxRate = txDelta / timeDelta;

                            // Sanity check: if rate exceeds 1 Gbps, something is wrong
                            const maxRate = 1024 * 1024 * 1024 / 8; // 1 Gbps in bytes/sec
                            if (rawRxRate > maxRate) rawRxRate = 0;
                            if (rawTxRate > maxRate) rawTxRate = 0;
                        }

                        history.prevRx = rxBytes;
                        history.prevTx = txBytes;
                        history.prevTime = now;

                        // Apply noise floor: rates below 10 KB/s are treated as zero
                        const noiseFloor = 10 * 1024; // 10 KB/s
                        const cleanRxRate = rawRxRate > noiseFloor ? rawRxRate : 0;
                        const cleanTxRate = rawTxRate > noiseFloor ? rawTxRate : 0;

                        // Store cleaned rates
                        history.rawRx.push(Math.max(0, cleanRxRate));
                        history.rawTx.push(Math.max(0, cleanTxRate));

                        // Keep last 30 raw samples for moving average calculation
                        if (history.rawRx.length > 30) {
                            history.rawRx.shift();
                            history.rawTx.shift();
                        }

                        // Calculate simple moving average over last 10 samples - EXACT COPY FROM CLASSIC VIEW
                        const windowSize = Math.min(10, history.rawRx.length);
                        const recentRx = history.rawRx.slice(-windowSize);
                        const recentTx = history.rawTx.slice(-windowSize);

                        const smoothedRx = recentRx.reduce((a, b) => a + b, 0) / windowSize;
                        const smoothedTx = recentTx.reduce((a, b) => a + b, 0) / windowSize;

                        // Add to history (keep last 240 data points = 60 seconds at 250ms polling)
                        history.timestamps.push(Math.floor(now / 1000));
                        history.rx.push(smoothedRx);
                        history.tx.push(smoothedTx);

                        if (history.timestamps.length > 240) {
                            history.timestamps.shift();
                            history.rx.shift();
                            history.tx.shift();
                        }
                    });

                    // Update charts if visible
                    this.$nextTick(() => this.updateMetricsCharts());
                },

                formatBytes(bytes) {
                    if (bytes === 0 || bytes == null) return '0 B';
                    const k = 1024;
                    const sizes = ['B', 'KB', 'MB', 'GB', 'TB'];
                    const i = Math.floor(Math.log(bytes) / Math.log(k));
                    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
                },

                // Global View: Show entire world map (Pacific to Pacific, -180¬∞ to +180¬∞)
                calculateMapCenter() {
                    // GLOBAL VIEW MODE: Always show the full world
                    // Center on prime meridian with slight eastward shift for balanced Pacific view
                    // Scale is fixed to ensure entire world (-180¬∞ to +180¬∞ longitude) is visible

                    return {
                        centerLon: 0,      // Prime meridian (Americas left, Europe/Africa center, Asia right)
                        centerLat: 10,     // Slight northern hemisphere bias for better land visibility
                        scale: 1.0         // Fixed scale - entire world always visible
                    };
                },

                async initTopologyGraph() {
                    const container = document.getElementById('topology-graph');
                    if (!container) return;

                    const width = container.clientWidth;
                    const height = container.clientHeight;

                    // Clear any existing SVG
                    d3.select('#topology-graph').selectAll('svg').remove();

                    // Create SVG
                    const svg = d3.select('#topology-graph')
                        .append('svg')
                        .attr('width', width)
                        .attr('height', height)
                        .attr('viewBox', [0, 0, width, height]);

                    // Global View: Fixed projection showing entire world
                    const { centerLon, centerLat, scale } = this.calculateMapCenter();

                    // Calculate scale to fit world map in viewport
                    // For Mercator projection, scale = viewport_width / (2œÄ)
                    const globalScale = (width / (2 * Math.PI)) * 0.95; // 0.95 for 5% padding

                    // Create projection for Global View
                    const projection = d3.geoMercator()
                        .center([centerLon, centerLat])
                        .scale(globalScale)
                        .translate([width / 2, height / 2]);

                    // Create groups for layers (order matters for z-index)
                    const mapLayer = svg.append('g').attr('class', 'map-layer');
                    const routesLayer = svg.append('g').attr('class', 'routes-layer');
                    const meshLayer = svg.append('g').attr('class', 'mesh-layer');
                    const meshNodesLayer = svg.append('g').attr('class', 'mesh-nodes-layer');
                    const endpointNodesLayer = svg.append('g').attr('class', 'endpoint-nodes-layer');
                    const labelsLayer = svg.append('g').attr('class', 'labels-layer');

                    this.networkGraph = {
                        svg,
                        projection,
                        mapLayer,
                        routesLayer,
                        meshLayer,
                        meshNodesLayer,
                        endpointNodesLayer,
                        labelsLayer,
                        width,
                        height
                    };

                    // Load world map
                    await this.loadWorldMap();
                },

                async loadWorldMap() {
                    if (!this.networkGraph) return;

                    try {
                        // Load world topology data
                        const world = await d3.json('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json');
                        const countries = topojson.feature(world, world.objects.countries);

                        // Draw countries with CORRECT projection
                        this.networkGraph.mapLayer
                            .selectAll('path')
                            .data(countries.features)
                            .enter()
                            .append('path')
                            .attr('d', d3.geoPath().projection(this.networkGraph.projection));

                    } catch (error) {
                        console.error('Failed to load world map:', error);
                    }
                },

                resizeTopologyGraph() {
                    if (!this.networkGraph) return;

                    const container = document.getElementById('topology-graph');
                    const newWidth = container.clientWidth;
                    const newHeight = container.clientHeight;

                    // Update SVG dimensions
                    this.networkGraph.svg
                        .attr('width', newWidth)
                        .attr('height', newHeight)
                        .attr('viewBox', [0, 0, newWidth, newHeight]);

                    // Recalculate smart center for new viewport
                    const { centerLon, centerLat, scale } = this.calculateMapCenter();

                    // Update projection with smart centering
                    this.networkGraph.projection
                        .center([centerLon, centerLat])
                        .scale((newWidth / 6.5) * scale)
                        .translate([newWidth / 2, newHeight / 2]);

                    // Update dimensions
                    this.networkGraph.width = newWidth;
                    this.networkGraph.height = newHeight;

                    // Redraw map
                    this.networkGraph.mapLayer
                        .selectAll('path')
                        .attr('d', d3.geoPath().projection(this.networkGraph.projection));

                    // Resize canvas overlay
                    this.resizeRoutesCanvas();

                    // Redraw topology (buildRoutesFromSvg is called within updateTopologyGraph)
                    this.updateTopologyGraph();
                },

                getRegionCoordinates(regionId) {
                    // Try to match region ID to known coordinates (improved matching)
                    const searchId = regionId.toLowerCase();

                    for (const [key, coords] of Object.entries(REGION_COORDINATES)) {
                        if (searchId.includes(key) || key.includes(searchId)) {
                            return coords;
                        }
                    }

                    // Default to center if unknown
                    console.warn(`No coordinates found for region: ${regionId}`);
                    return { lat: 0, lng: 60, name: regionId };
                },

                // Generate curved path for VPN routes
                generateCurvedPath(source, target) {
                    const dx = target.x - source.x;
                    const dy = target.y - source.y;
                    const dr = Math.sqrt(dx * dx + dy * dy);

                    // Add curvature (10% of distance)
                    const curve = dr * 0.1;

                    return `M${source.x},${source.y} Q${(source.x + target.x) / 2},${(source.y + target.y) / 2 - curve} ${target.x},${target.y}`;
                },

                // Check for mesh/endpoint overlaps
                checkOverlap(meshNode, endpointNode, threshold = 40) {
                    const dx = meshNode.x - endpointNode.x;
                    const dy = meshNode.y - endpointNode.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return distance < threshold;
                },

                // Check if two bounding boxes intersect
                boxesIntersect(box1, box2) {
                    return !(box1.x + box1.width < box2.x ||
                             box2.x + box2.width < box1.x ||
                             box1.y + box1.height < box2.y ||
                             box2.y + box2.height < box1.y);
                },

                // Check if a label bounding box collides with a circle
                boxIntersectsCircle(box, circle, radius) {
                    // Find the closest point on the rectangle to the circle center
                    const closestX = Math.max(box.x, Math.min(circle.x, box.x + box.width));
                    const closestY = Math.max(box.y, Math.min(circle.y, box.y + box.height));

                    // Calculate distance from closest point to circle center
                    const dx = closestX - circle.x;
                    const dy = closestY - circle.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    return distance < radius;
                },

                // Find best label position avoiding collisions (ENDPOINT LABELS ONLY)
                findBestLabelPosition(node, labelText, allCircles, placedLabels) {
                    const fontSize = 12;  // Endpoint labels only
                    const estimatedWidth = labelText.length * fontSize * 0.6; // Rough estimate
                    const estimatedHeight = fontSize + 4;
                    const markerRadius = 6;  // Endpoint marker radius
                    const padding = 6;

                    // Candidate positions in priority order (as specified)
                    const candidates = [
                        // 1. Right of marker (DEFAULT)
                        {
                            x: node.x + markerRadius + padding,
                            y: node.y - estimatedHeight / 2,
                            anchor: 'start',
                            yOffset: fontSize / 2,
                            needsLeaderLine: false
                        },
                        // 2. Left of marker
                        {
                            x: node.x - markerRadius - padding - estimatedWidth,
                            y: node.y - estimatedHeight / 2,
                            anchor: 'end',
                            yOffset: fontSize / 2,
                            needsLeaderLine: false
                        },
                        // 3. Below marker
                        {
                            x: node.x - estimatedWidth / 2,
                            y: node.y + markerRadius + padding,
                            anchor: 'middle',
                            yOffset: fontSize,
                            needsLeaderLine: false
                        },
                        // 4. Above marker
                        {
                            x: node.x - estimatedWidth / 2,
                            y: node.y - markerRadius - padding - estimatedHeight,
                            anchor: 'middle',
                            yOffset: fontSize,
                            needsLeaderLine: false
                        },
                        // 5. Diagonal above-right
                        {
                            x: node.x + markerRadius * 0.7 + padding,
                            y: node.y - markerRadius * 0.7 - padding - estimatedHeight,
                            anchor: 'start',
                            yOffset: fontSize,
                            needsLeaderLine: true
                        },
                        // 6. Diagonal above-left
                        {
                            x: node.x - markerRadius * 0.7 - padding - estimatedWidth,
                            y: node.y - markerRadius * 0.7 - padding - estimatedHeight,
                            anchor: 'end',
                            yOffset: fontSize,
                            needsLeaderLine: true
                        }
                    ];

                    // Try each candidate position
                    for (const candidate of candidates) {
                        const bbox = {
                            x: candidate.anchor === 'middle' ? candidate.x :
                               candidate.anchor === 'end' ? candidate.x - estimatedWidth : candidate.x,
                            y: candidate.y,
                            width: estimatedWidth,
                            height: estimatedHeight
                        };

                        let hasCollision = false;

                        // Check collision with all circles
                        for (const circle of allCircles) {
                            if (this.boxIntersectsCircle(bbox, circle, circle.radius)) {
                                hasCollision = true;
                                break;
                            }
                        }

                        // Check collision with previously placed labels
                        if (!hasCollision) {
                            for (const placedLabel of placedLabels) {
                                if (this.boxesIntersect(bbox, placedLabel)) {
                                    hasCollision = true;
                                    break;
                                }
                            }
                        }

                        // If no collision, use this position
                        if (!hasCollision) {
                            return {
                                x: candidate.anchor === 'middle' ? node.x :
                                   candidate.anchor === 'end' ? node.x - markerRadius - padding :
                                   node.x + markerRadius + padding,
                                y: candidate.y + candidate.yOffset,
                                anchor: candidate.anchor,
                                bbox: bbox,
                                needsLeaderLine: candidate.needsLeaderLine
                            };
                        }
                    }

                    // Fallback: use default position (right of marker) with smaller font and leader line
                    const reducedFontSize = fontSize * 0.9;
                    const reducedWidth = labelText.length * reducedFontSize * 0.6;
                    return {
                        x: node.x + markerRadius + padding,
                        y: node.y,
                        anchor: 'start',
                        bbox: {
                            x: node.x + markerRadius + padding,
                            y: node.y - reducedFontSize / 2,
                            width: reducedWidth,
                            height: reducedFontSize + 4
                        },
                        reducedFont: true,
                        needsLeaderLine: true
                    };
                },

                updateTopologyGraph() {
                    if (!this.networkGraph) return;

                    const { svg, projection, routesLayer, meshLayer, meshNodesLayer, endpointNodesLayer, labelsLayer, width, height } = this.networkGraph;

                    // Build graph data
                    const nodes = [];
                    const links = [];

                    // GLOBAL VIEW: Mesh radius scaled with viewport size (25% of viewport)
                    let meshRadius = Math.min(width, height) * 0.25;
                    const tiltAngle = 18; // degrees for 3D depth
                    const tiltRadians = (tiltAngle * Math.PI) / 180;

                    // Create endpoint nodes at CORRECT geographic locations using ipapi.co metadata
                    // Group endpoints by physical location to handle multiple endpoints at same coordinates
                    const locationGroups = this.groupEndpointsByLocation(this.vpnStatus.connections);
                    const endpointNodes = {};

                    locationGroups.forEach((group) => {
                        const projectedCoords = projection([group.lon, group.lat]);

                        if (projectedCoords) {
                            const [x, y] = projectedCoords;

                            if (group.isMulti) {
                                // Multiple endpoints in same country - create grouped node
                                // Label is just country name (cities rendered separately as tspans)
                                const groupLabel = group.countryName;

                                const groupNode = {
                                    id: `endpoint-group-${group.lat}-${group.lon}`,
                                    label: groupLabel,
                                    type: 'endpoint',
                                    isGroup: true,
                                    groupedEndpoints: group.endpoints,
                                    countryCode: group.countryCode,
                                    countryName: group.countryName,
                                    city: group.city,
                                    cities: group.cities,  // Array of city names for multi-line rendering
                                    lat: group.lat,
                                    lon: group.lon,
                                    locationUnknown: group.endpoints.some(e => this.endpointMetadata[e.endpoint_ip]?.locationUnknown),
                                    x: x,
                                    y: y
                                };

                                nodes.push(groupNode);

                                // Map all region_ids in this group to the same node
                                group.endpoints.forEach(conn => {
                                    endpointNodes[conn.region_id] = groupNode;
                                });
                            } else {
                                // Single endpoint at this location
                                const conn = group.endpoints[0];
                                const metadata = this.endpointMetadata[conn.endpoint_ip];

                                const endpointNode = {
                                    id: `endpoint-${conn.region_id}`,
                                    label: conn.region_name,
                                    type: 'endpoint',
                                    isGroup: false,
                                    region_id: conn.region_id,
                                    endpoint_ip: conn.endpoint_ip,
                                    countryCode: metadata.countryCode,
                                    city: metadata.city,
                                    lat: metadata.lat,
                                    lon: metadata.lon,
                                    locationUnknown: metadata.locationUnknown || false,
                                    x: x,
                                    y: y
                                };

                                nodes.push(endpointNode);
                                endpointNodes[conn.region_id] = endpointNode;
                            }
                        }
                    });

                    // GLOBAL VIEW: Mesh centered at viewport center (not endpoint-biased)
                    // This ensures the mesh is visually centered in the map container
                    const centerX = width / 2;
                    const centerY = height / 2;

                    // Calculate initial mesh positions
                    const deviceCount = this.devices.length;
                    const potentialDeviceNodes = [];

                    this.devices.forEach((device, idx) => {
                        const angle = (idx / deviceCount) * 2 * Math.PI - Math.PI / 2;

                        // Base position on circle
                        const baseX = centerX + meshRadius * Math.cos(angle);
                        const baseY = centerY + meshRadius * Math.sin(angle);

                        // Apply 3D tilt (y-axis rotation creates perspective)
                        const tiltOffset = Math.sin(angle) * meshRadius * Math.sin(tiltRadians) * 0.35;

                        potentialDeviceNodes.push({
                            id: `device-${device.id}`,
                            label: device.hostname,
                            type: 'device',
                            online: device.online,
                            region_id: device.region_id,
                            device_id: device.id,
                            routing_enabled: device.routing_enabled,
                            x: baseX,
                            y: baseY - tiltOffset,  // Tilt creates vertical offset
                            depth: Math.cos(angle),  // For depth sorting
                            angle: angle  // Store for potential rotation
                        });
                    });

                    // Check for overlaps and adjust radius if needed
                    let hasOverlap = false;
                    const endpointList = Object.values(endpointNodes);

                    for (const meshNode of potentialDeviceNodes) {
                        for (const endpoint of endpointList) {
                            if (this.checkOverlap(meshNode, endpoint)) {
                                hasOverlap = true;
                                break;
                            }
                        }
                        if (hasOverlap) break;
                    }

                    // If overlap detected, reduce mesh radius slightly
                    if (hasOverlap) {
                        meshRadius *= 0.85;

                        // Recalculate positions with adjusted radius
                        potentialDeviceNodes.forEach((node, idx) => {
                            const angle = node.angle;
                            const baseX = centerX + meshRadius * Math.cos(angle);
                            const baseY = centerY + meshRadius * Math.sin(angle);
                            const tiltOffset = Math.sin(angle) * meshRadius * Math.sin(tiltRadians) * 0.35;

                            node.x = baseX;
                            node.y = baseY - tiltOffset;
                        });
                    }

                    // Add device nodes to main nodes array
                    nodes.push(...potentialDeviceNodes);

                    // Sort devices by depth for proper layering
                    const deviceNodes = nodes.filter(n => n.type === 'device').sort((a, b) => a.depth - b.depth);

                    // Add VPN route lines (device ‚Üí endpoint) as CURVED paths
                    deviceNodes.forEach(deviceNode => {
                        if (deviceNode.region_id && deviceNode.routing_enabled) {
                            const endpointNode = endpointNodes[deviceNode.region_id];
                            if (endpointNode) {
                                links.push({
                                    source: deviceNode,
                                    target: endpointNode,
                                    type: 'vpn',
                                    device_id: deviceNode.device_id,
                                    region_id: deviceNode.region_id
                                });
                            }
                        }
                    });

                    // Add mesh connections between devices
                    for (let i = 0; i < deviceNodes.length; i++) {
                        for (let j = i + 1; j < deviceNodes.length; j++) {
                            links.push({
                                source: deviceNodes[i],
                                target: deviceNodes[j],
                                type: 'mesh'
                            });
                        }
                    }

                    // Determine dimming based on filter
                    const isFiltered = this.selectedEndpoint !== null;

                    // Update route lines with CURVED paths
                    const routeLink = routesLayer.selectAll('path')
                        .data(links.filter(l => l.type === 'vpn'), d => `${d.source.id}-${d.target.id}`);

                    routeLink.exit().remove();

                    routeLink.enter()
                        .append('path')
                        .attr('class', 'network-link-vpn')
                        .merge(routeLink)
                        .attr('d', d => this.generateCurvedPath(d.source, d.target))
                        .classed('dimmed', d => isFiltered && d.region_id !== this.selectedEndpoint);

                    // Update mesh lines
                    const meshLink = meshLayer.selectAll('line')
                        .data(links.filter(l => l.type === 'mesh'), d => `${d.source.id}-${d.target.id}`);

                    meshLink.exit().remove();

                    meshLink.enter()
                        .append('line')
                        .attr('class', 'network-link-mesh')
                        .merge(meshLink)
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y)
                        .classed('dimmed', d =>
                            isFiltered &&
                            d.source.region_id !== this.selectedEndpoint &&
                            d.target.region_id !== this.selectedEndpoint
                        );

                    // Update mesh nodes
                    const meshNode = meshNodesLayer.selectAll('g')
                        .data(deviceNodes, d => d.id);

                    meshNode.exit().remove();

                    const meshNodeEnter = meshNode.enter()
                        .append('g')
                        .attr('class', 'mesh-node')
                        .on('click', (event, d) => {
                            this.selectDevice(d.device_id);
                        });

                    meshNodeEnter.append('circle').attr('r', 14);  // Smaller radius

                    const allMeshNodes = meshNodeEnter.merge(meshNode);

                    allMeshNodes
                        .attr('transform', d => `translate(${d.x},${d.y})`)
                        .classed('selected', d => this.selectedDevice === d.device_id)
                        .classed('dimmed', d => isFiltered && d.region_id !== this.selectedEndpoint);

                    allMeshNodes.select('circle')
                        .attr('fill', d => d.online ? '#3b82f6' : '#6b7280')
                        .attr('stroke', '#fff')
                        .attr('stroke-width', 2);

                    // Update endpoint nodes (SMALLER size)
                    const endpointNode = endpointNodesLayer.selectAll('g')
                        .data(nodes.filter(n => n.type === 'endpoint'), d => d.id);

                    endpointNode.exit().remove();

                    const endpointNodeEnter = endpointNode.enter()
                        .append('g')
                        .attr('class', 'endpoint-node')
                        .on('click', (event, d) => {
                            // For grouped endpoints, select the first region in the group
                            if (d.isGroup && d.groupedEndpoints && d.groupedEndpoints.length > 0) {
                                this.selectEndpointFilter(d.groupedEndpoints[0].region_id);
                            } else {
                                this.selectEndpointFilter(d.region_id);
                            }
                        });

                    endpointNodeEnter.append('circle')
                        .attr('class', 'endpoint-marker')
                        .attr('r', 6);  // Global View: smaller for spacious feeling

                    // Add outer ring for grouped endpoints
                    endpointNodeEnter.append('circle')
                        .attr('class', 'endpoint-group-ring')
                        .attr('r', 10)
                        .attr('fill', 'none')
                        .attr('stroke', '#10b981')
                        .attr('stroke-width', 2)
                        .attr('opacity', 0);  // Hidden by default, shown only for groups

                    const allEndpointNodes = endpointNodeEnter.merge(endpointNode);

                    allEndpointNodes
                        .attr('transform', d => `translate(${d.x},${d.y})`)
                        .classed('selected', d => this.selectedEndpoint === d.region_id)
                        .classed('dimmed', d => isFiltered && this.selectedEndpoint !== d.region_id);

                    allEndpointNodes.select('circle.endpoint-marker')
                        .attr('fill', '#10b981')
                        .attr('stroke', '#fff')
                        .attr('stroke-width', 1.5);

                    // Show outer ring only for grouped endpoints
                    allEndpointNodes.select('circle.endpoint-group-ring')
                        .attr('opacity', d => d.isGroup ? 0.6 : 0);

                    // Update labels - FIXED for mesh nodes, collision-avoiding for endpoints
                    labelsLayer.selectAll('*').remove();

                    // Build list of all circles (for endpoint collision detection)
                    const allCircles = [
                        ...deviceNodes.map(n => ({ x: n.x, y: n.y, radius: 14 })),
                        ...nodes.filter(n => n.type === 'endpoint').map(n => ({ x: n.x, y: n.y, radius: 6 }))
                    ];

                    const placedLabels = [];

                    // MESH NODE LABELS - FIXED POSITION (centered below, no collision avoidance)
                    deviceNodes.forEach(node => {
                        const labelText = node.label.length > 10 ? node.label.substring(0, 10) + '...' : node.label;

                        labelsLayer.append('text')
                            .attr('class', 'mesh-label')
                            .attr('x', node.x)
                            .attr('y', node.y + 26)  // Fixed offset below node
                            .attr('text-anchor', 'middle')  // Always centered
                            .classed('dimmed', isFiltered && node.region_id !== this.selectedEndpoint)
                            .text(labelText);
                    });

                    // ENDPOINT LABELS - COLLISION AVOIDANCE ENABLED
                    nodes.filter(n => n.type === 'endpoint').forEach(node => {
                        const position = this.findBestLabelPosition(node, node.label, allCircles, placedLabels);

                        if (node.isGroup && node.cities && node.cities.length > 0) {
                            // Multi-line label for grouped endpoints: Country name + cities as vertical list
                            const labelGroup = labelsLayer.append('g')
                                .attr('class', 'endpoint-label-group')
                                .classed('dimmed', isFiltered && this.selectedEndpoint !== node.region_id);

                            // Country name (bold) using tspan for proper SVG multi-line
                            const countryText = labelGroup.append('text')
                                .attr('x', position.x)
                                .attr('y', position.y)
                                .attr('text-anchor', position.anchor);

                            countryText.append('tspan')
                                .attr('x', position.x)
                                .attr('dy', 0)
                                .style('font-size', '12px')
                                .style('font-weight', 'bold')
                                .style('fill', 'white')
                                .text(node.countryName);

                            // Cities as vertical list using tspans
                            node.cities.forEach((city, index) => {
                                countryText.append('tspan')
                                    .attr('x', position.x)
                                    .attr('dy', index === 0 ? '14' : '12')  // First city: 14px below country, rest: 12px apart
                                    .style('font-size', '10px')
                                    .style('fill', '#94a3b8')
                                    .text(city);
                            });
                        } else {
                            // Single-line label for single endpoints
                            labelsLayer.append('text')
                                .attr('class', 'endpoint-label')
                                .attr('x', position.x)
                                .attr('y', position.y)
                                .attr('text-anchor', position.anchor)
                                .classed('dimmed', isFiltered && this.selectedEndpoint !== node.region_id)
                                .style('font-size', position.reducedFont ? '10px' : '12px')
                                .text(node.label);
                        }

                        // Add leader line if label was repositioned far from marker
                        if (position.needsLeaderLine) {
                            labelsLayer.append('line')
                                .attr('x1', node.x)
                                .attr('y1', node.y)
                                .attr('x2', position.x)
                                .attr('y2', position.y - 4)
                                .attr('stroke', '#64748b')
                                .attr('stroke-width', 0.5)
                                .attr('stroke-dasharray', '2,2')
                                .attr('opacity', 0.5);
                        }

                        placedLabels.push(position.bbox);
                    });

                    // Rebuild canvas routes after SVG topology update
                    this.$nextTick(() => {
                        this.buildRoutesFromSvg();
                    });
                },

            // ULTRA-LIGHTWEIGHT CANVAS CHART - Zero GPU overhead
            updateMetricsCharts() {
                if (!this.selectedEndpoint || this.selectedEndpoint === null) return;

                const connection = this.vpnStatus.connections.find(c => c.region_id === this.selectedEndpoint);
                if (!connection) return;

                const history = this.metricsData[connection.interface];
                if (!history || history.timestamps.length < 2) return;

                this.renderCanvasChart(history);
            },

            renderCanvasChart(data) {
                const canvas = document.getElementById('throughput-canvas');
                if (!canvas) return;

                const ctx = canvas.getContext('2d', { alpha: false }); // Disable alpha for performance
                const width = canvas.width;
                const height = canvas.height;

                // Clear canvas - solid fill (no transparency)
                ctx.fillStyle = '#1e293b'; // bg-slate-800
                ctx.fillRect(0, 0, width, height);

                if (!data || data.rx.length < 2) return;

                // Find max value for Y-scale (calculated ONCE, not per frame)
                const maxRx = Math.max(...data.rx);
                const maxTx = Math.max(...data.tx);
                const maxValue = Math.max(maxRx, maxTx);
                if (maxValue === 0) return;

                // Add 10% padding to max for visual breathing room
                const yMax = maxValue * 1.1;

                // Chart dimensions
                const padding = { top: 10, right: 10, bottom: 20, left: 72 };
                const chartWidth = width - padding.left - padding.right;
                const chartHeight = height - padding.top - padding.bottom;

                // Draw grid lines (5 horizontal lines, static)
                ctx.strokeStyle = '#374151'; // Subtle gray
                ctx.lineWidth = 1;
                for (let i = 0; i <= 4; i++) {
                    const y = padding.top + (chartHeight / 4) * i;
                    ctx.beginPath();
                    ctx.moveTo(padding.left, y);
                    ctx.lineTo(width - padding.right, y);
                    ctx.stroke();
                }

                // Draw Y-axis labels
                ctx.fillStyle = '#9ca3af';
                ctx.font = '11px monospace';
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                for (let i = 0; i <= 4; i++) {
                    const value = yMax - (yMax / 4) * i;
                    const y = padding.top + (chartHeight / 4) * i;
                    ctx.fillText(this.formatBytes(value) + '/s', padding.left - 5, y);
                }

                // Helper: map data value to canvas Y coordinate
                const dataToY = (value) => {
                    const ratio = value / yMax;
                    return padding.top + chartHeight - (ratio * chartHeight);
                };

                // Helper: map data index to canvas X coordinate
                const indexToX = (index, total) => {
                    const ratio = index / (total - 1);
                    return padding.left + (ratio * chartWidth);
                };

                const pointCount = data.rx.length;

                // Helper: Draw smooth Catmull-Rom curve through points
                const drawSmoothCurve = (dataArray, color) => {
                    if (pointCount < 2) return;

                    // Build point array
                    const points = [];
                    for (let i = 0; i < pointCount; i++) {
                        points.push({
                            x: indexToX(i, pointCount),
                            y: dataToY(dataArray[i])
                        });
                    }

                    ctx.strokeStyle = color;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);

                    if (pointCount === 2) {
                        // Just draw a straight line for 2 points
                        ctx.lineTo(points[1].x, points[1].y);
                    } else {
                        // Catmull-Rom curve through all points
                        for (let i = 0; i < pointCount - 1; i++) {
                            const p0 = points[i === 0 ? i : i - 1];
                            const p1 = points[i];
                            const p2 = points[i + 1];
                            const p3 = points[i + 2 < pointCount ? i + 2 : i + 1];

                            // Catmull-Rom to Bezier conversion (tension = 0.5)
                            const cp1x = p1.x + (p2.x - p0.x) / 6;
                            const cp1y = p1.y + (p2.y - p0.y) / 6;
                            const cp2x = p2.x - (p3.x - p1.x) / 6;
                            const cp2y = p2.y - (p3.y - p1.y) / 6;

                            ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
                        }
                    }

                    ctx.stroke();
                };

                // Draw download line (green) - SMOOTH CURVES
                drawSmoothCurve(data.rx, '#22c55e');

                // Draw upload line (blue) - SMOOTH CURVES
                drawSmoothCurve(data.tx, '#3b82f6');

                // Optional: Draw small points on lines (only if performance allows)
                // Commented out by default for maximum performance
                /*
                ctx.fillStyle = '#22c55e';
                for (let i = 0; i < pointCount; i += 5) { // Every 5th point
                    const x = indexToX(i, pointCount);
                    const y = dataToY(data.rx[i]);
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.fillStyle = '#3b82f6';
                for (let i = 0; i < pointCount; i += 5) {
                    const x = indexToX(i, pointCount);
                    const y = dataToY(data.tx[i]);
                    ctx.beginPath();
                    ctx.arc(x, y, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
                */
            },

            // Helper methods for summary cards
            getCurrentDownloadRate() {
                const connection = this.vpnStatus.connections?.find(c => c.region_id === this.selectedEndpoint);
                if (!connection) return '-';
                const history = this.metricsData[connection.interface];
                if (!history || history.rx.length === 0) return '-';
                return this.formatBytes(history.rx[history.rx.length - 1]) + '/s';
            },

            getCurrentUploadRate() {
                const connection = this.vpnStatus.connections?.find(c => c.region_id === this.selectedEndpoint);
                if (!connection) return '-';
                const history = this.metricsData[connection.interface];
                if (!history || history.tx.length === 0) return '-';
                return this.formatBytes(history.tx[history.tx.length - 1]) + '/s';
            },

            // Average calculation methods for summary stats (over the full 2-minute buffer)
            getAverageDownloadRate() {
                const connection = this.vpnStatus.connections?.find(c => c.region_id === this.selectedEndpoint);
                if (!connection) return '-';
                const history = this.metricsData[connection.interface];
                if (!history || history.rx.length === 0) return '-';

                const sum = history.rx.reduce((acc, val) => acc + val, 0);
                const avg = sum / history.rx.length;
                return this.formatBytes(avg) + '/s';
            },

            getAverageUploadRate() {
                const connection = this.vpnStatus.connections?.find(c => c.region_id === this.selectedEndpoint);
                if (!connection) return '-';
                const history = this.metricsData[connection.interface];
                if (!history || history.tx.length === 0) return '-';

                const sum = history.tx.reduce((acc, val) => acc + val, 0);
                const avg = sum / history.tx.length;
                return this.formatBytes(avg) + '/s';
            },

            hasMetricsData() {
                const connection = this.vpnStatus.connections?.find(c => c.region_id === this.selectedEndpoint);
                if (!connection) return false;
                const history = this.metricsData[connection.interface];
                return history && history.timestamps.length >= 2;
            },

            getSelectedEndpointName() {
                const connection = this.vpnStatus.connections?.find(c => c.region_id === this.selectedEndpoint);
                return connection ? connection.region_name : '';
            }
        }
    }
    </script>
</body>
</html>
