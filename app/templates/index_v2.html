<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PIA Router - Geographic Topology</title>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
    <style>
        /* Prevent scrolling on main viewport */
        html, body {
            overflow-x: hidden;
            max-width: 100vw;
            background: #0a0e1a;
        }

        /* Topology container */
        #topology-graph {
            background: linear-gradient(135deg, #0a0e1a 0%, #0f172a 100%);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        /* World map layer */
        .map-layer path {
            fill: #1e3a5f;
            stroke: #334155;
            stroke-width: 0.5px;
            opacity: 0.25;
        }

        /* Mesh connection lines - 3D effect with shadow */
        .network-link-mesh {
            stroke: #475569;
            stroke-width: 1;
            stroke-dasharray: 4 4;
            fill: none;
            opacity: 0.3;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.4));
        }

        .network-link-mesh.dimmed {
            opacity: 0.1;
        }

        /* VPN route lines - curved paths */
        .network-link-vpn {
            stroke: #60a5fa;
            stroke-width: 2;
            fill: none;
            opacity: 0.7;
            stroke-dasharray: 6 4;
            animation: dash-route 20s linear infinite;
        }

        .network-link-vpn.dimmed {
            opacity: 0.2;
            stroke: #475569;
        }

        .network-link-vpn:hover,
        .network-link-vpn.highlighted {
            stroke: #fbbf24;
            stroke-width: 3;
            opacity: 1;
            filter: drop-shadow(0 0 4px rgba(251, 191, 36, 0.8));
        }

        @keyframes dash-route {
            to {
                stroke-dashoffset: -200;
            }
        }

        /* Endpoint nodes (geographic PIA servers) - smaller with glow */
        .endpoint-node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .endpoint-node circle {
            filter: drop-shadow(0 0 6px rgba(16, 185, 129, 0.5));
        }

        .endpoint-node.dimmed circle {
            opacity: 0.3;
            filter: drop-shadow(0 0 2px rgba(16, 185, 129, 0.2));
        }

        .endpoint-node:hover circle {
            transform: scale(1.2);
            filter: drop-shadow(0 0 10px rgba(16, 185, 129, 0.8));
        }

        .endpoint-node.selected circle {
            filter: brightness(1.3) drop-shadow(0 0 12px rgba(251, 191, 36, 0.9));
        }

        /* Mesh nodes (Tailscale devices) - 3D depth with shadows */
        .mesh-node {
            cursor: pointer;
            transition: all 0.3s ease;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.5));
        }

        .mesh-node.dimmed {
            opacity: 0.3;
        }

        .mesh-node:hover {
            filter: brightness(1.2) drop-shadow(0 6px 12px rgba(0, 0, 0, 0.6));
        }

        .mesh-node.selected {
            filter: brightness(1.5) drop-shadow(0 0 12px rgba(59, 130, 246, 0.8));
        }

        /* Labels with dark halo for readability */
        .endpoint-label {
            font-size: 11px;
            font-weight: 600;
            fill: #ffffff;
            paint-order: stroke;
            stroke: #000000;
            stroke-width: 3px;
            stroke-linecap: round;
            stroke-linejoin: round;
            pointer-events: none;
        }

        .endpoint-label.dimmed {
            opacity: 0.3;
        }

        .mesh-label {
            font-size: 10px;
            font-weight: 500;
            fill: #f1f5f9;
            opacity: 1;
            paint-order: stroke;
            stroke: #000000;
            stroke-width: 2.5px;
            stroke-linecap: round;
            stroke-linejoin: round;
            pointer-events: none;
        }

        .mesh-label.dimmed {
            opacity: 0.3;
        }

        /* All Endpoints pill */
        .all-endpoints-pill {
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            border: 1px solid #475569;
            transition: all 0.3s ease;
        }

        .all-endpoints-pill.active {
            background: linear-gradient(135deg, #1e40af 0%, #2563eb 100%);
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
        }

        .all-endpoints-pill:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        /* Equal-width endpoint pill styles */
        .endpoint-pill-equal {
            flex: 1 1 0;
            min-width: 200px;
            max-width: 280px;
            border-width: 1px;
        }

        .endpoint-pill-equal:hover:not(.bg-blue-600) {
            background-color: #334155 !important;
        }

        /* Hover state for slate-750 */
        .hover\:bg-slate-750:hover {
            background-color: #334155;
        }

        /* Map expand toggle button */
        .expand-toggle {
            position: absolute;
            top: 12px;
            right: 12px;
            z-index: 10;
            background: rgba(30, 41, 59, 0.9);
            border: 1px solid #475569;
            border-radius: 6px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .expand-toggle:hover {
            background: rgba(51, 65, 85, 0.9);
            border-color: #64748b;
        }

        /* Device table styles */
        .device-table {
            font-size: 14px;
        }

        .device-row {
            height: 40px;
            transition: background-color 0.2s ease;
        }

        .device-row:hover {
            background-color: rgba(59, 130, 246, 0.1);
        }

        .device-row.selected {
            background-color: rgba(59, 130, 246, 0.2);
        }

        /* Status indicators */
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        /* Custom scrollbar for device table */
        .device-table-container::-webkit-scrollbar {
            width: 6px;
        }

        .device-table-container::-webkit-scrollbar-track {
            background: #1e293b;
        }

        .device-table-container::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 3px;
        }

        /* Transition for layout changes */
        .topology-container,
        .table-container {
            transition: width 0.3s ease;
        }
    </style>
</head>
<body class="bg-slate-950 text-slate-100" x-data="app()" x-init="init()">
    <!-- Header (60px) -->
    <header class="bg-slate-900 border-b border-slate-800 px-6 py-3">
        <div class="flex items-center justify-between">
            <h1 class="text-xl font-bold text-white">PIA Router - Geographic Topology</h1>
            <div class="flex items-center space-x-6">
                <!-- Compact Status Indicators -->
                <div class="flex items-center space-x-2">
                    <div :class="vpnStatus.active_count > 0 ? 'bg-green-500' : 'bg-slate-500'" class="status-dot"></div>
                    <span class="text-sm text-slate-300"><span x-text="vpnStatus.active_count"></span> VPN</span>
                </div>
                <div class="flex items-center space-x-2">
                    <div :class="tailscaleStatus.running ? 'bg-green-500' : 'bg-red-500'" class="status-dot"></div>
                    <span class="text-sm text-slate-300">Tailscale</span>
                </div>
                <div class="flex items-center space-x-2">
                    <div :class="systemHealth.healthy ? 'bg-green-500' : 'bg-yellow-500'" class="status-dot"></div>
                    <span class="text-sm text-slate-300">System</span>
                </div>
                <a href="/settings" class="text-blue-400 hover:text-blue-300 text-sm font-medium">Settings</a>
                <a href="/" class="text-slate-400 hover:text-slate-300 text-sm">Classic View</a>
            </div>
        </div>
    </header>

    <!-- Endpoint Pills - Equal Width, Multi-Row Wrap, Two-Line Layout -->
    <div class="bg-slate-900 border-b border-slate-800 px-6 py-3">
        <div class="flex items-center gap-3 mb-2">
            <span class="text-sm text-slate-400 flex-shrink-0">Filter:</span>
        </div>
        <div class="flex gap-2 flex-wrap">
            <!-- All Endpoints Pill (Equal Width, Two-Line) -->
            <div
                class="endpoint-pill-equal flex items-center gap-3 rounded-lg px-4 py-2.5 cursor-pointer transition-all border"
                :class="selectedEndpoint === null ? 'bg-blue-600 border-blue-500' : 'bg-slate-800 border-slate-700 hover:bg-slate-750'"
                @click="clearEndpointFilter()">
                <span class="text-xl flex-shrink-0 leading-none">üåê</span>
                <div class="flex flex-col justify-center min-w-0 flex-1">
                    <span class="font-semibold text-white text-sm leading-snug">All Endpoints</span>
                    <span class="text-slate-300 text-xs leading-snug">Global View</span>
                </div>
            </div>

            <!-- Endpoint Pills (Equal Width, Two-Line) -->
            <template x-for="conn in vpnStatus.connections" :key="conn.region_id">
                <div
                    class="endpoint-pill-equal flex items-center gap-3 rounded-lg px-4 py-2.5 cursor-pointer transition-all border"
                    :class="selectedEndpoint === conn.region_id ? 'bg-blue-600 border-blue-500' : 'bg-slate-800 border-slate-700 hover:bg-slate-750'"
                    @click="selectEndpointFilter(conn.region_id); fetchEndpointMetadata(conn.endpoint_ip)">

                    <!-- Country flag (from ipapi.co) -->
                    <span class="text-xl flex-shrink-0 leading-none" x-text="getCountryFlagEmoji(endpointMetadata[conn.endpoint_ip]?.countryCode || '??')"></span>

                    <!-- Two-line text layout -->
                    <div class="flex flex-col justify-center min-w-0 flex-1">
                        <!-- Line 1: Endpoint name (bold) -->
                        <span class="font-semibold text-white text-sm leading-snug truncate" x-text="conn.region_name"></span>
                        <!-- Line 2: IP address -->
                        <span class="text-slate-300 text-xs font-mono leading-snug truncate" x-text="conn.endpoint_ip || '...'"></span>
                    </div>
                </div>
            </template>
        </div>
    </div>

    <!-- Main Content: Split View (Graph + Table) -->
    <main class="px-6 py-4" style="height: calc(100vh - 140px);">
        <div class="flex space-x-4 h-full">
            <!-- LEFT: Geographic Topology (expandable) -->
            <div class="topology-container flex-shrink-0 relative" :class="mapExpanded ? 'w-[85%]' : 'w-3/5'">
                <div class="bg-slate-900 rounded-lg border border-slate-800 p-4 h-full flex flex-col">
                    <div class="flex items-center justify-between mb-3">
                        <h2 class="text-lg font-semibold text-white">Network Topology</h2>

                        <!-- Expand/Collapse Toggle -->
                        <button
                            @click="mapExpanded = !mapExpanded"
                            class="expand-toggle"
                            :title="mapExpanded ? 'Collapse map' : 'Expand map'">
                            <svg x-show="!mapExpanded" class="w-5 h-5 text-slate-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path>
                            </svg>
                            <svg x-show="mapExpanded" class="w-5 h-5 text-slate-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                    <div id="topology-graph" class="flex-1 min-h-0"></div>
                </div>
            </div>

            <!-- RIGHT: Device Routing Table (collapsible) -->
            <div class="table-container flex-shrink-0" :class="mapExpanded ? 'w-[15%]' : 'w-2/5'">
                <div class="bg-slate-900 rounded-lg border border-slate-800 p-4 h-full flex flex-col">
                    <div class="flex items-center justify-between mb-3">
                        <h2 class="text-lg font-semibold text-white" x-show="!mapExpanded">Device Routing</h2>
                        <h2 class="text-sm font-semibold text-white" x-show="mapExpanded">Devices</h2>
                        <span class="text-sm text-slate-400"><span x-text="filteredDevices.length"></span><span x-show="!mapExpanded"> / <span x-text="devices.length"></span></span></span>
                    </div>

                    <!-- Scrollable table container -->
                    <div class="device-table-container flex-1 min-h-0 overflow-y-auto">
                        <table class="device-table w-full" x-show="!mapExpanded">
                            <thead class="sticky top-0 bg-slate-800 text-slate-300 text-xs uppercase">
                                <tr>
                                    <th class="px-3 py-2 text-left">Device</th>
                                    <th class="px-3 py-2 text-left">IP</th>
                                    <th class="px-3 py-2 text-left">Region</th>
                                    <th class="px-3 py-2 text-center">Route</th>
                                </tr>
                            </thead>
                            <tbody>
                                <template x-for="device in filteredDevices" :key="device.id">
                                    <tr
                                        class="device-row border-b border-slate-800"
                                        :class="selectedDevice === device.id ? 'selected' : ''"
                                        @click="selectDevice(device.id)">
                                        <td class="px-3 py-2">
                                            <div class="flex items-center space-x-2">
                                                <div :class="device.online ? 'bg-green-500' : 'bg-slate-500'" class="w-2 h-2 rounded-full"></div>
                                                <span class="font-medium text-white truncate" x-text="device.hostname"></span>
                                            </div>
                                        </td>
                                        <td class="px-3 py-2 text-slate-400 text-sm" x-text="device.ip_addresses[0]"></td>
                                        <td class="px-3 py-2" x-data="{
                                            open: false,
                                            search: '',
                                            deviceId: device.id,
                                            get filteredRegions() {
                                                if (!this.search) return regions;
                                                const s = this.search.toLowerCase();
                                                return regions.filter(r =>
                                                    r.name.toLowerCase().includes(s) ||
                                                    r.country.toLowerCase().includes(s) ||
                                                    r.id.toLowerCase().includes(s)
                                                );
                                            },
                                            selectRegion(regionId) {
                                                setDeviceRegion(this.deviceId, regionId);
                                                this.open = false;
                                                this.search = '';
                                            }
                                        }">
                                            <div class="relative" @click.away="open = false">
                                                <!-- Dropdown trigger -->
                                                <button
                                                    @click.stop="open = !open"
                                                    class="bg-slate-800 border border-slate-700 rounded px-2 py-1 text-sm text-white w-full text-left flex items-center justify-between"
                                                    type="button">
                                                    <span x-text="device.region_id ? (regions.find(r => r.id === device.region_id)?.name || 'Unknown') : 'No VPN'"></span>
                                                    <svg class="w-4 h-4 ml-2" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                                                    </svg>
                                                </button>

                                                <!-- Dropdown menu -->
                                                <div
                                                    x-show="open"
                                                    x-cloak
                                                    class="absolute z-50 mt-1 w-64 bg-slate-800 border border-slate-700 rounded shadow-xl max-h-80 overflow-hidden"
                                                    style="display: none;">
                                                    <!-- Search input -->
                                                    <div class="p-2 border-b border-slate-700">
                                                        <input
                                                            x-model="search"
                                                            @click.stop
                                                            type="text"
                                                            placeholder="Search regions..."
                                                            class="w-full bg-slate-900 border border-slate-600 rounded px-2 py-1 text-sm text-white focus:outline-none focus:border-blue-500">
                                                    </div>

                                                    <!-- Options list -->
                                                    <div class="overflow-y-auto max-h-64">
                                                        <!-- No VPN option -->
                                                        <div
                                                            @click.stop="selectRegion('')"
                                                            class="px-3 py-2 text-sm text-white hover:bg-slate-700 cursor-pointer"
                                                            :class="!device.region_id ? 'bg-slate-700' : ''">
                                                            No VPN
                                                        </div>

                                                        <!-- Region options -->
                                                        <template x-for="region in filteredRegions" :key="region.id">
                                                            <div
                                                                @click.stop="selectRegion(region.id)"
                                                                class="px-3 py-2 text-sm text-white hover:bg-slate-700 cursor-pointer"
                                                                :class="device.region_id === region.id ? 'bg-slate-700' : ''">
                                                                <div class="font-medium" x-text="region.name"></div>
                                                                <div class="text-xs text-slate-400" x-text="region.country"></div>
                                                            </div>
                                                        </template>

                                                        <!-- No results -->
                                                        <div x-show="search && filteredRegions.length === 0" class="px-3 py-2 text-sm text-slate-400 italic">
                                                            No regions found
                                                        </div>
                                                    </div>
                                                </div>
                                            </div>
                                        </td>
                                        <td class="px-3 py-2 text-center">
                                            <button
                                                @click.stop="toggleDeviceRouting(device.id)"
                                                :disabled="!device.region_id || isDeviceActionInFlight(device.id)"
                                                class="w-8 h-8 rounded-full transition-colors relative"
                                                :class="{
                                                    'bg-red-600 hover:bg-red-700': device.routing_enabled && !isDeviceActionInFlight(device.id),
                                                    'bg-green-600 hover:bg-green-700': !device.routing_enabled && device.region_id && !isDeviceActionInFlight(device.id),
                                                    'bg-slate-700 cursor-not-allowed': !device.region_id || isDeviceActionInFlight(device.id),
                                                    'opacity-50': isDeviceActionInFlight(device.id)
                                                }"
                                                :title="isDeviceActionInFlight(device.id) ? (device.routing_enabled ? 'Stopping...' : 'Starting...') : (device.routing_enabled ? 'Stop routing' : (device.region_id ? 'Start routing' : 'Select region first'))">
                                                <!-- Spinner (when in-flight) -->
                                                <svg x-show="isDeviceActionInFlight(device.id)" class="animate-spin w-4 h-4 mx-auto text-white" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                                                </svg>
                                                <!-- Play Icon -->
                                                <svg x-show="!device.routing_enabled && !isDeviceActionInFlight(device.id)" class="w-4 h-4 mx-auto" fill="currentColor" viewBox="0 0 24 24">
                                                    <path d="M8 5v14l11-7z"/>
                                                </svg>
                                                <!-- Stop Icon -->
                                                <svg x-show="device.routing_enabled && !isDeviceActionInFlight(device.id)" class="w-4 h-4 mx-auto" fill="currentColor" viewBox="0 0 24 24">
                                                    <path d="M6 6h12v12H6z"/>
                                                </svg>
                                            </button>
                                        </td>
                                    </tr>
                                </template>
                            </tbody>
                        </table>

                        <!-- Compact view when expanded -->
                        <div x-show="mapExpanded" class="space-y-2">
                            <template x-for="device in filteredDevices" :key="device.id">
                                <div
                                    class="p-2 bg-slate-800 rounded border border-slate-700 cursor-pointer hover:bg-slate-750"
                                    :class="selectedDevice === device.id ? 'bg-slate-700' : ''"
                                    @click="selectDevice(device.id)">
                                    <div class="flex items-center space-x-2">
                                        <div :class="device.online ? 'bg-green-500' : 'bg-slate-500'" class="w-2 h-2 rounded-full flex-shrink-0"></div>
                                        <span class="text-xs font-medium text-white truncate" x-text="device.hostname"></span>
                                    </div>
                                </div>
                            </template>
                        </div>

                        <div x-show="filteredDevices.length === 0" class="text-center py-8 text-slate-500 text-sm">
                            No devices found
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // Geographic coordinates for PIA regions (CORRECTED)
        const REGION_COORDINATES = {
            'sg': { lat: 1.3521, lng: 103.8198, name: 'Singapore' },
            'singapore': { lat: 1.3521, lng: 103.8198, name: 'Singapore' },
            'kh': { lat: 11.5564, lng: 104.9282, name: 'Cambodia' },
            'cambodia': { lat: 11.5564, lng: 104.9282, name: 'Cambodia' },
            'alaska': { lat: 61.2181, lng: -149.9003, name: 'US Alaska' },
            'melbourne': { lat: -37.8136, lng: 144.9631, name: 'AU Melbourne' },
            'sydney': { lat: -33.8688, lng: 151.2093, name: 'AU Sydney' },
            'perth': { lat: -31.9505, lng: 115.8605, name: 'AU Perth' },
            'japan': { lat: 35.6762, lng: 139.6503, name: 'Japan' },
            'tokyo': { lat: 35.6762, lng: 139.6503, name: 'Japan' },
            'hong': { lat: 22.3193, lng: 114.1694, name: 'Hong Kong' },
            'india': { lat: 19.0760, lng: 72.8777, name: 'India' },
            'mumbai': { lat: 19.0760, lng: 72.8777, name: 'India' },
            'zealand': { lat: -36.8485, lng: 174.7633, name: 'New Zealand' },
            'auckland': { lat: -36.8485, lng: 174.7633, name: 'New Zealand' },
            'london': { lat: 51.5074, lng: -0.1278, name: 'UK London' },
            'uk': { lat: 51.5074, lng: -0.1278, name: 'UK' },
            'germany': { lat: 52.5200, lng: 13.4050, name: 'Germany' },
            'berlin': { lat: 52.5200, lng: 13.4050, name: 'Germany' },
            'france': { lat: 48.8566, lng: 2.3522, name: 'France' },
            'paris': { lat: 48.8566, lng: 2.3522, name: 'France' },
            'netherlands': { lat: 52.3676, lng: 4.9041, name: 'Netherlands' },
            'amsterdam': { lat: 52.3676, lng: 4.9041, name: 'Netherlands' },
            'california': { lat: 37.7749, lng: -122.4194, name: 'US California' },
            'newyork': { lat: 40.7128, lng: -74.0060, name: 'US New York' },
            'texas': { lat: 29.7604, lng: -95.3698, name: 'US Texas' },
            'houston': { lat: 29.7604, lng: -95.3698, name: 'US Texas' },
            'canada': { lat: 43.6532, lng: -79.3832, name: 'Canada' },
            'toronto': { lat: 43.6532, lng: -79.3832, name: 'Canada' },
            'brazil': { lat: -23.5505, lng: -46.6333, name: 'Brazil' },
            'paulo': { lat: -23.5505, lng: -46.6333, name: 'Brazil' },
            'africa': { lat: -33.9249, lng: 18.4241, name: 'South Africa' },
            'capetown': { lat: -33.9249, lng: 18.4241, name: 'South Africa' }
        };

        function app() {
            return {
                loading: false,
                vpnStatus: { active_count: 0, connections: [] },
                tailscaleStatus: { running: false, exit_node_enabled: false, hostname: null },
                systemHealth: { healthy: false, messages: [] },
                regions: [],
                devices: [],
                selectedEndpoint: null,  // null = "All Endpoints"
                selectedDevice: null,
                mapExpanded: false,
                pollInterval: null,
                networkGraph: null,
                resizeObserver: null,
                endpointMetadata: {},  // Cache for endpoint IP/country data from ipapi.co
                deviceStates: {},  // Track device routing states: {deviceId: 'running'|'stopping'|'stopped'|'error'}
                inFlightRequests: new Set(),  // Track in-flight API requests to prevent duplicates

                get filteredDevices() {
                    if (this.selectedEndpoint === null) return this.devices;
                    return this.devices.filter(d => d.region_id === this.selectedEndpoint && d.routing_enabled);
                },

                getDeviceState(deviceId) {
                    if (this.deviceStates[deviceId]) return this.deviceStates[deviceId];
                    const device = this.devices.find(d => d.id === deviceId);
                    return device?.routing_enabled ? 'running' : 'stopped';
                },

                isDeviceActionInFlight(deviceId) {
                    return this.inFlightRequests.has(deviceId);
                },

                async init() {
                    await this.loadRegions();
                    await this.refreshStatus();
                    await this.initTopologyGraph();

                    // Poll status every 5 seconds
                    this.pollInterval = setInterval(() => {
                        this.refreshStatus();
                    }, 5000);

                    // Use ResizeObserver for auto-resize
                    const container = document.getElementById('topology-graph');
                    if (container) {
                        this.resizeObserver = new ResizeObserver(() => {
                            this.resizeTopologyGraph();
                        });
                        this.resizeObserver.observe(container);
                    }
                },

                async loadRegions() {
                    try {
                        const response = await fetch('/api/settings/regions');
                        const data = await response.json();
                        this.regions = data.regions;
                    } catch (error) {
                        console.error('Failed to load regions:', error);
                    }
                },

                async refreshStatus() {
                    await Promise.all([
                        this.loadVPNStatus(),
                        this.loadTailscaleStatus(),
                        this.loadSystemHealth(),
                        this.loadDevices()
                    ]);

                    this.$nextTick(() => {
                        this.updateTopologyGraph();
                    });
                },

                async loadVPNStatus() {
                    try {
                        const response = await fetch('/api/status/vpn');
                        this.vpnStatus = await response.json();

                        // AWAIT all endpoint metadata fetching before rendering
                        if (this.vpnStatus.connections) {
                            const metadataPromises = this.vpnStatus.connections
                                .filter(conn => conn.endpoint_ip)
                                .map(conn => this.fetchEndpointMetadata(conn.endpoint_ip, conn.region_id));

                            await Promise.all(metadataPromises);
                            console.log('‚úì All endpoint metadata loaded');
                        }
                    } catch (error) {
                        console.error('Failed to load VPN status:', error);
                        this.vpnStatus = { active_count: 0, connections: [] };
                    }
                },

                async loadTailscaleStatus() {
                    try {
                        const response = await fetch('/api/status/tailscale');
                        this.tailscaleStatus = await response.json();
                    } catch (error) {
                        console.error('Failed to load Tailscale status:', error);
                    }
                },

                async loadSystemHealth() {
                    try {
                        const response = await fetch('/api/status/health');
                        this.systemHealth = await response.json();
                    } catch (error) {
                        console.error('Failed to load system health:', error);
                    }
                },

                async loadDevices() {
                    try {
                        const response = await fetch('/api/devices');
                        const data = await response.json();
                        this.devices = data.devices;
                    } catch (error) {
                        console.error('Failed to load devices:', error);
                    }
                },

                // Fallback locations when ipapi.co fails (by region ID for specificity)
                getFallbackLocationByRegion(regionId, countryCode) {
                    const id = regionId ? regionId.toLowerCase() : '';

                    // Australia - specific cities
                    if (id.includes('perth')) return { lat: -31.9505, lon: 115.8605, city: 'Perth', countryName: 'Australia', countryCode: 'AU' };
                    if (id.includes('brisbane')) return { lat: -27.4698, lon: 153.0251, city: 'Brisbane', countryName: 'Australia', countryCode: 'AU' };
                    if (id.includes('melbourne')) return { lat: -37.8136, lon: 144.9631, city: 'Melbourne', countryName: 'Australia', countryCode: 'AU' };
                    if (id.includes('sydney')) return { lat: -33.8688, lon: 151.2093, city: 'Sydney', countryName: 'Australia', countryCode: 'AU' };

                    // Country-level fallbacks
                    const fallbacks = {
                        'AU': { lat: -37.8136, lon: 144.9631, city: 'Melbourne', countryName: 'Australia' },
                        'JP': { lat: 35.6762, lon: 139.6503, city: 'Tokyo', countryName: 'Japan' },
                        'SG': { lat: 1.3521, lon: 103.8198, city: 'Singapore', countryName: 'Singapore' },
                        'KH': { lat: 11.5564, lon: 104.9282, city: 'Phnom Penh', countryName: 'Cambodia' },
                        'US': { lat: 61.2181, lon: -149.9003, city: 'Anchorage', countryName: 'United States' },
                        'MC': { lat: 43.7384, lon: 7.4246, city: 'Monaco', countryName: 'Monaco' },
                        'NZ': { lat: -36.8485, lon: 174.7633, city: 'Auckland', countryName: 'New Zealand' },
                        'HK': { lat: 22.3193, lon: 114.1694, city: 'Hong Kong', countryName: 'Hong Kong' },
                        'IN': { lat: 19.0760, lon: 72.8777, city: 'Mumbai', countryName: 'India' }
                    };
                    const fallback = fallbacks[countryCode] || { lat: 0, lon: 0, city: 'Unknown', countryName: 'Unknown' };
                    return { ...fallback, countryCode };
                },

                // Country center coordinates for grouping
                getCountryCenter(countryCode) {
                    const centers = {
                        'AU': { lat: -25.2744, lon: 133.7751 },  // Australia (geographic center)
                        'US': { lat: 39.8283, lon: -98.5795 },   // United States (geographic center)
                        'JP': { lat: 36.2048, lon: 138.2529 },   // Japan (geographic center)
                        'SG': { lat: 1.3521, lon: 103.8198 },    // Singapore (city-state)
                        'KH': { lat: 12.5657, lon: 104.9910 },   // Cambodia (geographic center)
                        'MC': { lat: 43.7384, lon: 7.4246 },     // Monaco (city-state)
                        'NZ': { lat: -40.9006, lon: 174.8860 },  // New Zealand (geographic center)
                        'HK': { lat: 22.3193, lon: 114.1694 },   // Hong Kong (city-state)
                        'IN': { lat: 20.5937, lon: 78.9629 }     // India (geographic center)
                    };
                    return centers[countryCode] || null;
                },

                // Group endpoints by country (single endpoint ‚Üí city, multiple ‚Üí country center)
                groupEndpointsByLocation(connections) {
                    const groups = [];
                    const processed = new Set();

                    // First, group by country code
                    const byCountry = {};
                    connections.forEach(conn => {
                        const metadata = this.endpointMetadata[conn.endpoint_ip];
                        if (!metadata || typeof metadata.lat !== 'number') return;

                        // Exception: Treat US Alaska separately from other US regions
                        const groupKey = (metadata.countryCode === 'US' && conn.region_id.toLowerCase().includes('alaska'))
                            ? 'US-ALASKA'
                            : metadata.countryCode;

                        if (!byCountry[groupKey]) {
                            byCountry[groupKey] = [];
                        }
                        byCountry[groupKey].push(conn);
                    });

                    // Create groups based on country count
                    Object.entries(byCountry).forEach(([groupKey, endpoints]) => {
                        if (endpoints.length === 1) {
                            // Single endpoint in country ‚Üí use city location
                            const conn = endpoints[0];
                            const metadata = this.endpointMetadata[conn.endpoint_ip];

                            groups.push({
                                lat: metadata.lat,
                                lon: metadata.lon,
                                city: metadata.city,
                                countryCode: metadata.countryCode,
                                countryName: metadata.countryName,
                                endpoints: endpoints,
                                isMulti: false,
                                isCityLevel: true
                            });
                        } else {
                            // Multiple endpoints in country ‚Üí use country center
                            const firstMetadata = this.endpointMetadata[endpoints[0].endpoint_ip];
                            const countryCode = groupKey === 'US-ALASKA' ? 'US' : groupKey;
                            const center = this.getCountryCenter(countryCode);

                            if (center) {
                                // Collect all unique cities
                                const cities = [...new Set(endpoints.map(e => {
                                    const m = this.endpointMetadata[e.endpoint_ip];
                                    return m?.city || 'Unknown';
                                }).filter(c => c !== 'Unknown'))];

                                groups.push({
                                    lat: center.lat,
                                    lon: center.lon,
                                    city: null,  // No single city
                                    cities: cities,  // List of cities
                                    countryCode: firstMetadata.countryCode,
                                    countryName: firstMetadata.countryName,
                                    endpoints: endpoints,
                                    isMulti: true,
                                    isCityLevel: false
                                });
                            } else {
                                // Fallback: use first endpoint's location
                                const metadata = this.endpointMetadata[endpoints[0].endpoint_ip];
                                groups.push({
                                    lat: metadata.lat,
                                    lon: metadata.lon,
                                    city: metadata.city,
                                    countryCode: metadata.countryCode,
                                    countryName: metadata.countryName,
                                    endpoints: endpoints,
                                    isMulti: true,
                                    isCityLevel: false
                                });
                            }
                        }
                    });

                    return groups;
                },

                // Guess country code from region ID
                guessCountryFromRegion(regionId) {
                    const id = regionId.toLowerCase();
                    if (id.includes('aus') || id.includes('melbourne') || id.includes('sydney') || id.includes('perth')) return 'AU';
                    if (id.includes('japan') || id.includes('jp') || id.includes('tokyo')) return 'JP';
                    if (id.includes('singapore') || id === 'sg') return 'SG';
                    if (id.includes('cambodia') || id === 'kh') return 'KH';
                    if (id.includes('alaska') || id.includes('us')) return 'US';
                    if (id.includes('monaco') || id === 'mc') return 'MC';
                    if (id.includes('hong') || id === 'hk') return 'HK';
                    if (id.includes('india') || id.includes('mumbai')) return 'IN';
                    if (id.includes('zealand') || id === 'nz') return 'NZ';
                    return null;
                },

                async fetchEndpointMetadata(endpointIP, regionId = null) {
                    // Check cache first
                    if (this.endpointMetadata[endpointIP]) {
                        return this.endpointMetadata[endpointIP];
                    }

                    try {
                        const response = await fetch(`https://ipapi.co/${endpointIP}/json/`);
                        const data = await response.json();

                        // Validate we got valid data
                        if (!data.country_code || typeof data.latitude !== 'number' || typeof data.longitude !== 'number') {
                            throw new Error('Invalid response from ipapi.co');
                        }

                        const metadata = {
                            ip: endpointIP,
                            countryCode: data.country_code,
                            countryName: data.country_name || 'Unknown',
                            city: data.city || null,
                            lat: data.latitude,
                            lon: data.longitude,
                            locationUnknown: false
                        };

                        // Cache the result
                        this.endpointMetadata[endpointIP] = metadata;
                        console.log(`‚úì Resolved ${endpointIP}: ${metadata.countryCode} ${metadata.city || ''} (${metadata.lat}, ${metadata.lon})`);
                        return metadata;
                    } catch (error) {
                        console.warn(`‚ö† Failed to fetch metadata for ${endpointIP}, using fallback:`, error);

                        // Try to guess country from region ID
                        const guessedCountry = regionId ? this.guessCountryFromRegion(regionId) : null;
                        const fallbackCountry = guessedCountry || 'AU'; // Default to Australia if can't guess
                        const fallback = this.getFallbackLocationByRegion(regionId, fallbackCountry);

                        const metadata = {
                            ip: endpointIP,
                            countryCode: fallback.countryCode,
                            countryName: fallback.countryName,
                            city: fallback.city,
                            lat: fallback.lat,
                            lon: fallback.lon,
                            locationUnknown: true
                        };

                        this.endpointMetadata[endpointIP] = metadata;
                        console.log(`‚ö† Using fallback for ${endpointIP} (${regionId}): ${metadata.countryCode} ${metadata.city} (${metadata.lat}, ${metadata.lon})`);
                        return metadata;
                    }
                },

                getCountryFlagEmoji(countryCode) {
                    if (!countryCode || countryCode === '??') return 'üåê';

                    // Convert ISO country code to flag emoji
                    // Each letter mapped to regional indicator symbol (üá¶ = U+1F1E6)
                    const codePoints = countryCode
                        .toUpperCase()
                        .split('')
                        .map(char => 127397 + char.charCodeAt());
                    return String.fromCodePoint(...codePoints);
                },

                async setDeviceRegion(deviceId, regionId) {
                    try {
                        const response = await fetch(`/api/devices/${deviceId}/region`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ region_id: regionId || null })
                        });

                        if (!response.ok) {
                            const error = await response.json();
                            alert('Failed to set device region: ' + error.detail);
                        }

                        await this.loadDevices();
                        await this.loadVPNStatus();
                    } catch (error) {
                        alert('Failed to set device region: ' + error.message);
                    }
                },

                async toggleDeviceRouting(deviceId) {
                    // Prevent duplicate requests (debouncing)
                    if (this.inFlightRequests.has(deviceId)) {
                        console.log(`Ignoring duplicate toggle request for device ${deviceId}`);
                        return;
                    }

                    const device = this.devices.find(d => d.id === deviceId);
                    if (!device) return;

                    const currentState = this.getDeviceState(deviceId);

                    // State machine: only allow transitions from running ‚Üí stopping or stopped ‚Üí starting
                    if (currentState === 'stopping' || currentState === 'starting') {
                        console.log(`Device ${deviceId} is already ${currentState}, ignoring click`);
                        return;
                    }

                    // Determine action
                    const isCurrentlyRunning = device.routing_enabled;
                    const action = isCurrentlyRunning ? 'stop' : 'start';

                    // Optional confirmation for stop action
                    if (isCurrentlyRunning) {
                        if (!confirm(`Stop routing ${device.hostname} through VPN?`)) {
                            return;
                        }
                    }

                    try {
                        // Transition to intermediate state
                        this.deviceStates[deviceId] = isCurrentlyRunning ? 'stopping' : 'starting';
                        this.inFlightRequests.add(deviceId);

                        const response = await fetch(`/api/devices/${deviceId}/toggle`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({})
                        });

                        if (!response.ok) {
                            const error = await response.json();
                            throw new Error(error.detail || 'Unknown error');
                        }

                        // Success: transition to final state
                        this.deviceStates[deviceId] = isCurrentlyRunning ? 'stopped' : 'running';

                        // Refresh data to sync with backend
                        await this.loadDevices();
                        await this.loadVPNStatus();

                        // Clear state after refresh (let backend state be source of truth)
                        setTimeout(() => {
                            delete this.deviceStates[deviceId];
                        }, 500);

                    } catch (error) {
                        console.error(`Failed to ${action} routing for device ${deviceId}:`, error);

                        // Error state
                        this.deviceStates[deviceId] = 'error';
                        alert(`Failed to ${action} routing for ${device.hostname}: ${error.message}`);

                        // Clear error state after 3 seconds
                        setTimeout(() => {
                            delete this.deviceStates[deviceId];
                        }, 3000);

                    } finally {
                        // Always remove from in-flight set
                        this.inFlightRequests.delete(deviceId);
                    }
                },

                clearEndpointFilter() {
                    this.selectedEndpoint = null;
                    this.$nextTick(() => {
                        this.updateTopologyGraph();
                    });
                },

                selectEndpointFilter(regionId) {
                    // Clicking same endpoint does NOT clear - must click "All Endpoints"
                    this.selectedEndpoint = regionId;
                    this.$nextTick(() => {
                        this.updateTopologyGraph();
                    });
                },

                selectDevice(deviceId) {
                    if (this.selectedDevice === deviceId) {
                        this.selectedDevice = null;
                    } else {
                        this.selectedDevice = deviceId;
                    }
                    this.$nextTick(() => {
                        this.updateTopologyGraph();
                    });
                },

                // Global View: Show entire world map (Pacific to Pacific, -180¬∞ to +180¬∞)
                calculateMapCenter() {
                    // GLOBAL VIEW MODE: Always show the full world
                    // Center on prime meridian with slight eastward shift for balanced Pacific view
                    // Scale is fixed to ensure entire world (-180¬∞ to +180¬∞ longitude) is visible

                    return {
                        centerLon: 0,      // Prime meridian (Americas left, Europe/Africa center, Asia right)
                        centerLat: 10,     // Slight northern hemisphere bias for better land visibility
                        scale: 1.0         // Fixed scale - entire world always visible
                    };
                },

                async initTopologyGraph() {
                    const container = document.getElementById('topology-graph');
                    if (!container) return;

                    const width = container.clientWidth;
                    const height = container.clientHeight;

                    // Clear any existing SVG
                    d3.select('#topology-graph').selectAll('svg').remove();

                    // Create SVG
                    const svg = d3.select('#topology-graph')
                        .append('svg')
                        .attr('width', width)
                        .attr('height', height)
                        .attr('viewBox', [0, 0, width, height]);

                    // Global View: Fixed projection showing entire world
                    const { centerLon, centerLat, scale } = this.calculateMapCenter();

                    // Calculate scale to fit world map in viewport
                    // For Mercator projection, scale = viewport_width / (2œÄ)
                    const globalScale = (width / (2 * Math.PI)) * 0.95; // 0.95 for 5% padding

                    // Create projection for Global View
                    const projection = d3.geoMercator()
                        .center([centerLon, centerLat])
                        .scale(globalScale)
                        .translate([width / 2, height / 2]);

                    // Create groups for layers (order matters for z-index)
                    const mapLayer = svg.append('g').attr('class', 'map-layer');
                    const routesLayer = svg.append('g').attr('class', 'routes-layer');
                    const meshLayer = svg.append('g').attr('class', 'mesh-layer');
                    const meshNodesLayer = svg.append('g').attr('class', 'mesh-nodes-layer');
                    const endpointNodesLayer = svg.append('g').attr('class', 'endpoint-nodes-layer');
                    const labelsLayer = svg.append('g').attr('class', 'labels-layer');

                    this.networkGraph = {
                        svg,
                        projection,
                        mapLayer,
                        routesLayer,
                        meshLayer,
                        meshNodesLayer,
                        endpointNodesLayer,
                        labelsLayer,
                        width,
                        height
                    };

                    // Load world map
                    await this.loadWorldMap();
                },

                async loadWorldMap() {
                    if (!this.networkGraph) return;

                    try {
                        // Load world topology data
                        const world = await d3.json('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json');
                        const countries = topojson.feature(world, world.objects.countries);

                        // Draw countries with CORRECT projection
                        this.networkGraph.mapLayer
                            .selectAll('path')
                            .data(countries.features)
                            .enter()
                            .append('path')
                            .attr('d', d3.geoPath().projection(this.networkGraph.projection));

                    } catch (error) {
                        console.error('Failed to load world map:', error);
                    }
                },

                resizeTopologyGraph() {
                    if (!this.networkGraph) return;

                    const container = document.getElementById('topology-graph');
                    const newWidth = container.clientWidth;
                    const newHeight = container.clientHeight;

                    // Update SVG dimensions
                    this.networkGraph.svg
                        .attr('width', newWidth)
                        .attr('height', newHeight)
                        .attr('viewBox', [0, 0, newWidth, newHeight]);

                    // Recalculate smart center for new viewport
                    const { centerLon, centerLat, scale } = this.calculateMapCenter();

                    // Update projection with smart centering
                    this.networkGraph.projection
                        .center([centerLon, centerLat])
                        .scale((newWidth / 6.5) * scale)
                        .translate([newWidth / 2, newHeight / 2]);

                    // Update dimensions
                    this.networkGraph.width = newWidth;
                    this.networkGraph.height = newHeight;

                    // Redraw map
                    this.networkGraph.mapLayer
                        .selectAll('path')
                        .attr('d', d3.geoPath().projection(this.networkGraph.projection));

                    // Redraw topology
                    this.updateTopologyGraph();
                },

                getRegionCoordinates(regionId) {
                    // Try to match region ID to known coordinates (improved matching)
                    const searchId = regionId.toLowerCase();

                    for (const [key, coords] of Object.entries(REGION_COORDINATES)) {
                        if (searchId.includes(key) || key.includes(searchId)) {
                            return coords;
                        }
                    }

                    // Default to center if unknown
                    console.warn(`No coordinates found for region: ${regionId}`);
                    return { lat: 0, lng: 60, name: regionId };
                },

                // Generate curved path for VPN routes
                generateCurvedPath(source, target) {
                    const dx = target.x - source.x;
                    const dy = target.y - source.y;
                    const dr = Math.sqrt(dx * dx + dy * dy);

                    // Add curvature (10% of distance)
                    const curve = dr * 0.1;

                    return `M${source.x},${source.y} Q${(source.x + target.x) / 2},${(source.y + target.y) / 2 - curve} ${target.x},${target.y}`;
                },

                // Check for mesh/endpoint overlaps
                checkOverlap(meshNode, endpointNode, threshold = 40) {
                    const dx = meshNode.x - endpointNode.x;
                    const dy = meshNode.y - endpointNode.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return distance < threshold;
                },

                // Check if two bounding boxes intersect
                boxesIntersect(box1, box2) {
                    return !(box1.x + box1.width < box2.x ||
                             box2.x + box2.width < box1.x ||
                             box1.y + box1.height < box2.y ||
                             box2.y + box2.height < box1.y);
                },

                // Check if a label bounding box collides with a circle
                boxIntersectsCircle(box, circle, radius) {
                    // Find the closest point on the rectangle to the circle center
                    const closestX = Math.max(box.x, Math.min(circle.x, box.x + box.width));
                    const closestY = Math.max(box.y, Math.min(circle.y, box.y + box.height));

                    // Calculate distance from closest point to circle center
                    const dx = closestX - circle.x;
                    const dy = closestY - circle.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    return distance < radius;
                },

                // Find best label position avoiding collisions (ENDPOINT LABELS ONLY)
                findBestLabelPosition(node, labelText, allCircles, placedLabels) {
                    const fontSize = 12;  // Endpoint labels only
                    const estimatedWidth = labelText.length * fontSize * 0.6; // Rough estimate
                    const estimatedHeight = fontSize + 4;
                    const markerRadius = 6;  // Endpoint marker radius
                    const padding = 6;

                    // Candidate positions in priority order (as specified)
                    const candidates = [
                        // 1. Right of marker (DEFAULT)
                        {
                            x: node.x + markerRadius + padding,
                            y: node.y - estimatedHeight / 2,
                            anchor: 'start',
                            yOffset: fontSize / 2,
                            needsLeaderLine: false
                        },
                        // 2. Left of marker
                        {
                            x: node.x - markerRadius - padding - estimatedWidth,
                            y: node.y - estimatedHeight / 2,
                            anchor: 'end',
                            yOffset: fontSize / 2,
                            needsLeaderLine: false
                        },
                        // 3. Below marker
                        {
                            x: node.x - estimatedWidth / 2,
                            y: node.y + markerRadius + padding,
                            anchor: 'middle',
                            yOffset: fontSize,
                            needsLeaderLine: false
                        },
                        // 4. Above marker
                        {
                            x: node.x - estimatedWidth / 2,
                            y: node.y - markerRadius - padding - estimatedHeight,
                            anchor: 'middle',
                            yOffset: fontSize,
                            needsLeaderLine: false
                        },
                        // 5. Diagonal above-right
                        {
                            x: node.x + markerRadius * 0.7 + padding,
                            y: node.y - markerRadius * 0.7 - padding - estimatedHeight,
                            anchor: 'start',
                            yOffset: fontSize,
                            needsLeaderLine: true
                        },
                        // 6. Diagonal above-left
                        {
                            x: node.x - markerRadius * 0.7 - padding - estimatedWidth,
                            y: node.y - markerRadius * 0.7 - padding - estimatedHeight,
                            anchor: 'end',
                            yOffset: fontSize,
                            needsLeaderLine: true
                        }
                    ];

                    // Try each candidate position
                    for (const candidate of candidates) {
                        const bbox = {
                            x: candidate.anchor === 'middle' ? candidate.x :
                               candidate.anchor === 'end' ? candidate.x - estimatedWidth : candidate.x,
                            y: candidate.y,
                            width: estimatedWidth,
                            height: estimatedHeight
                        };

                        let hasCollision = false;

                        // Check collision with all circles
                        for (const circle of allCircles) {
                            if (this.boxIntersectsCircle(bbox, circle, circle.radius)) {
                                hasCollision = true;
                                break;
                            }
                        }

                        // Check collision with previously placed labels
                        if (!hasCollision) {
                            for (const placedLabel of placedLabels) {
                                if (this.boxesIntersect(bbox, placedLabel)) {
                                    hasCollision = true;
                                    break;
                                }
                            }
                        }

                        // If no collision, use this position
                        if (!hasCollision) {
                            return {
                                x: candidate.anchor === 'middle' ? node.x :
                                   candidate.anchor === 'end' ? node.x - markerRadius - padding :
                                   node.x + markerRadius + padding,
                                y: candidate.y + candidate.yOffset,
                                anchor: candidate.anchor,
                                bbox: bbox,
                                needsLeaderLine: candidate.needsLeaderLine
                            };
                        }
                    }

                    // Fallback: use default position (right of marker) with smaller font and leader line
                    const reducedFontSize = fontSize * 0.9;
                    const reducedWidth = labelText.length * reducedFontSize * 0.6;
                    return {
                        x: node.x + markerRadius + padding,
                        y: node.y,
                        anchor: 'start',
                        bbox: {
                            x: node.x + markerRadius + padding,
                            y: node.y - reducedFontSize / 2,
                            width: reducedWidth,
                            height: reducedFontSize + 4
                        },
                        reducedFont: true,
                        needsLeaderLine: true
                    };
                },

                updateTopologyGraph() {
                    if (!this.networkGraph) return;

                    const { svg, projection, routesLayer, meshLayer, meshNodesLayer, endpointNodesLayer, labelsLayer, width, height } = this.networkGraph;

                    // Build graph data
                    const nodes = [];
                    const links = [];

                    // GLOBAL VIEW: Mesh radius scaled with viewport size (25% of viewport)
                    let meshRadius = Math.min(width, height) * 0.25;
                    const tiltAngle = 18; // degrees for 3D depth
                    const tiltRadians = (tiltAngle * Math.PI) / 180;

                    // Create endpoint nodes at CORRECT geographic locations using ipapi.co metadata
                    // Group endpoints by physical location to handle multiple endpoints at same coordinates
                    const locationGroups = this.groupEndpointsByLocation(this.vpnStatus.connections);
                    const endpointNodes = {};

                    locationGroups.forEach((group) => {
                        const projectedCoords = projection([group.lon, group.lat]);

                        if (projectedCoords) {
                            const [x, y] = projectedCoords;

                            if (group.isMulti) {
                                // Multiple endpoints in same country - create grouped node
                                // Label is just country name (cities rendered separately as tspans)
                                const groupLabel = group.countryName;

                                const groupNode = {
                                    id: `endpoint-group-${group.lat}-${group.lon}`,
                                    label: groupLabel,
                                    type: 'endpoint',
                                    isGroup: true,
                                    groupedEndpoints: group.endpoints,
                                    countryCode: group.countryCode,
                                    countryName: group.countryName,
                                    city: group.city,
                                    cities: group.cities,  // Array of city names for multi-line rendering
                                    lat: group.lat,
                                    lon: group.lon,
                                    locationUnknown: group.endpoints.some(e => this.endpointMetadata[e.endpoint_ip]?.locationUnknown),
                                    x: x,
                                    y: y
                                };

                                nodes.push(groupNode);

                                // Map all region_ids in this group to the same node
                                group.endpoints.forEach(conn => {
                                    endpointNodes[conn.region_id] = groupNode;
                                });
                            } else {
                                // Single endpoint at this location
                                const conn = group.endpoints[0];
                                const metadata = this.endpointMetadata[conn.endpoint_ip];

                                const endpointNode = {
                                    id: `endpoint-${conn.region_id}`,
                                    label: conn.region_name,
                                    type: 'endpoint',
                                    isGroup: false,
                                    region_id: conn.region_id,
                                    endpoint_ip: conn.endpoint_ip,
                                    countryCode: metadata.countryCode,
                                    city: metadata.city,
                                    lat: metadata.lat,
                                    lon: metadata.lon,
                                    locationUnknown: metadata.locationUnknown || false,
                                    x: x,
                                    y: y
                                };

                                nodes.push(endpointNode);
                                endpointNodes[conn.region_id] = endpointNode;
                            }
                        }
                    });

                    // GLOBAL VIEW: Mesh centered at viewport center (not endpoint-biased)
                    // This ensures the mesh is visually centered in the map container
                    const centerX = width / 2;
                    const centerY = height / 2;

                    // Calculate initial mesh positions
                    const deviceCount = this.devices.length;
                    const potentialDeviceNodes = [];

                    this.devices.forEach((device, idx) => {
                        const angle = (idx / deviceCount) * 2 * Math.PI - Math.PI / 2;

                        // Base position on circle
                        const baseX = centerX + meshRadius * Math.cos(angle);
                        const baseY = centerY + meshRadius * Math.sin(angle);

                        // Apply 3D tilt (y-axis rotation creates perspective)
                        const tiltOffset = Math.sin(angle) * meshRadius * Math.sin(tiltRadians) * 0.35;

                        potentialDeviceNodes.push({
                            id: `device-${device.id}`,
                            label: device.hostname,
                            type: 'device',
                            online: device.online,
                            region_id: device.region_id,
                            device_id: device.id,
                            routing_enabled: device.routing_enabled,
                            x: baseX,
                            y: baseY - tiltOffset,  // Tilt creates vertical offset
                            depth: Math.cos(angle),  // For depth sorting
                            angle: angle  // Store for potential rotation
                        });
                    });

                    // Check for overlaps and adjust radius if needed
                    let hasOverlap = false;
                    const endpointList = Object.values(endpointNodes);

                    for (const meshNode of potentialDeviceNodes) {
                        for (const endpoint of endpointList) {
                            if (this.checkOverlap(meshNode, endpoint)) {
                                hasOverlap = true;
                                break;
                            }
                        }
                        if (hasOverlap) break;
                    }

                    // If overlap detected, reduce mesh radius slightly
                    if (hasOverlap) {
                        meshRadius *= 0.85;

                        // Recalculate positions with adjusted radius
                        potentialDeviceNodes.forEach((node, idx) => {
                            const angle = node.angle;
                            const baseX = centerX + meshRadius * Math.cos(angle);
                            const baseY = centerY + meshRadius * Math.sin(angle);
                            const tiltOffset = Math.sin(angle) * meshRadius * Math.sin(tiltRadians) * 0.35;

                            node.x = baseX;
                            node.y = baseY - tiltOffset;
                        });
                    }

                    // Add device nodes to main nodes array
                    nodes.push(...potentialDeviceNodes);

                    // Sort devices by depth for proper layering
                    const deviceNodes = nodes.filter(n => n.type === 'device').sort((a, b) => a.depth - b.depth);

                    // Add VPN route lines (device ‚Üí endpoint) as CURVED paths
                    deviceNodes.forEach(deviceNode => {
                        if (deviceNode.region_id && deviceNode.routing_enabled) {
                            const endpointNode = endpointNodes[deviceNode.region_id];
                            if (endpointNode) {
                                links.push({
                                    source: deviceNode,
                                    target: endpointNode,
                                    type: 'vpn',
                                    device_id: deviceNode.device_id,
                                    region_id: deviceNode.region_id
                                });
                            }
                        }
                    });

                    // Add mesh connections between devices
                    for (let i = 0; i < deviceNodes.length; i++) {
                        for (let j = i + 1; j < deviceNodes.length; j++) {
                            links.push({
                                source: deviceNodes[i],
                                target: deviceNodes[j],
                                type: 'mesh'
                            });
                        }
                    }

                    // Determine dimming based on filter
                    const isFiltered = this.selectedEndpoint !== null;

                    // Update route lines with CURVED paths
                    const routeLink = routesLayer.selectAll('path')
                        .data(links.filter(l => l.type === 'vpn'), d => `${d.source.id}-${d.target.id}`);

                    routeLink.exit().remove();

                    routeLink.enter()
                        .append('path')
                        .attr('class', 'network-link-vpn')
                        .merge(routeLink)
                        .attr('d', d => this.generateCurvedPath(d.source, d.target))
                        .classed('dimmed', d => isFiltered && d.region_id !== this.selectedEndpoint);

                    // Update mesh lines
                    const meshLink = meshLayer.selectAll('line')
                        .data(links.filter(l => l.type === 'mesh'), d => `${d.source.id}-${d.target.id}`);

                    meshLink.exit().remove();

                    meshLink.enter()
                        .append('line')
                        .attr('class', 'network-link-mesh')
                        .merge(meshLink)
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y)
                        .classed('dimmed', d =>
                            isFiltered &&
                            d.source.region_id !== this.selectedEndpoint &&
                            d.target.region_id !== this.selectedEndpoint
                        );

                    // Update mesh nodes
                    const meshNode = meshNodesLayer.selectAll('g')
                        .data(deviceNodes, d => d.id);

                    meshNode.exit().remove();

                    const meshNodeEnter = meshNode.enter()
                        .append('g')
                        .attr('class', 'mesh-node')
                        .on('click', (event, d) => {
                            this.selectDevice(d.device_id);
                        });

                    meshNodeEnter.append('circle').attr('r', 14);  // Smaller radius

                    const allMeshNodes = meshNodeEnter.merge(meshNode);

                    allMeshNodes
                        .attr('transform', d => `translate(${d.x},${d.y})`)
                        .classed('selected', d => this.selectedDevice === d.device_id)
                        .classed('dimmed', d => isFiltered && d.region_id !== this.selectedEndpoint);

                    allMeshNodes.select('circle')
                        .attr('fill', d => d.online ? '#3b82f6' : '#6b7280')
                        .attr('stroke', '#fff')
                        .attr('stroke-width', 2);

                    // Update endpoint nodes (SMALLER size)
                    const endpointNode = endpointNodesLayer.selectAll('g')
                        .data(nodes.filter(n => n.type === 'endpoint'), d => d.id);

                    endpointNode.exit().remove();

                    const endpointNodeEnter = endpointNode.enter()
                        .append('g')
                        .attr('class', 'endpoint-node')
                        .on('click', (event, d) => {
                            // For grouped endpoints, select the first region in the group
                            if (d.isGroup && d.groupedEndpoints && d.groupedEndpoints.length > 0) {
                                this.selectEndpointFilter(d.groupedEndpoints[0].region_id);
                            } else {
                                this.selectEndpointFilter(d.region_id);
                            }
                        });

                    endpointNodeEnter.append('circle')
                        .attr('class', 'endpoint-marker')
                        .attr('r', 6);  // Global View: smaller for spacious feeling

                    // Add outer ring for grouped endpoints
                    endpointNodeEnter.append('circle')
                        .attr('class', 'endpoint-group-ring')
                        .attr('r', 10)
                        .attr('fill', 'none')
                        .attr('stroke', '#10b981')
                        .attr('stroke-width', 2)
                        .attr('opacity', 0);  // Hidden by default, shown only for groups

                    const allEndpointNodes = endpointNodeEnter.merge(endpointNode);

                    allEndpointNodes
                        .attr('transform', d => `translate(${d.x},${d.y})`)
                        .classed('selected', d => this.selectedEndpoint === d.region_id)
                        .classed('dimmed', d => isFiltered && this.selectedEndpoint !== d.region_id);

                    allEndpointNodes.select('circle.endpoint-marker')
                        .attr('fill', '#10b981')
                        .attr('stroke', '#fff')
                        .attr('stroke-width', 1.5);

                    // Show outer ring only for grouped endpoints
                    allEndpointNodes.select('circle.endpoint-group-ring')
                        .attr('opacity', d => d.isGroup ? 0.6 : 0);

                    // Update labels - FIXED for mesh nodes, collision-avoiding for endpoints
                    labelsLayer.selectAll('*').remove();

                    // Build list of all circles (for endpoint collision detection)
                    const allCircles = [
                        ...deviceNodes.map(n => ({ x: n.x, y: n.y, radius: 14 })),
                        ...nodes.filter(n => n.type === 'endpoint').map(n => ({ x: n.x, y: n.y, radius: 6 }))
                    ];

                    const placedLabels = [];

                    // MESH NODE LABELS - FIXED POSITION (centered below, no collision avoidance)
                    deviceNodes.forEach(node => {
                        const labelText = node.label.length > 10 ? node.label.substring(0, 10) + '...' : node.label;

                        labelsLayer.append('text')
                            .attr('class', 'mesh-label')
                            .attr('x', node.x)
                            .attr('y', node.y + 26)  // Fixed offset below node
                            .attr('text-anchor', 'middle')  // Always centered
                            .classed('dimmed', isFiltered && node.region_id !== this.selectedEndpoint)
                            .text(labelText);
                    });

                    // ENDPOINT LABELS - COLLISION AVOIDANCE ENABLED
                    nodes.filter(n => n.type === 'endpoint').forEach(node => {
                        const position = this.findBestLabelPosition(node, node.label, allCircles, placedLabels);

                        if (node.isGroup && node.cities && node.cities.length > 0) {
                            // Multi-line label for grouped endpoints: Country name + cities as vertical list
                            const labelGroup = labelsLayer.append('g')
                                .attr('class', 'endpoint-label-group')
                                .classed('dimmed', isFiltered && this.selectedEndpoint !== node.region_id);

                            // Country name (bold) using tspan for proper SVG multi-line
                            const countryText = labelGroup.append('text')
                                .attr('x', position.x)
                                .attr('y', position.y)
                                .attr('text-anchor', position.anchor);

                            countryText.append('tspan')
                                .attr('x', position.x)
                                .attr('dy', 0)
                                .style('font-size', '12px')
                                .style('font-weight', 'bold')
                                .style('fill', 'white')
                                .text(node.countryName);

                            // Cities as vertical list using tspans
                            node.cities.forEach((city, index) => {
                                countryText.append('tspan')
                                    .attr('x', position.x)
                                    .attr('dy', index === 0 ? '14' : '12')  // First city: 14px below country, rest: 12px apart
                                    .style('font-size', '10px')
                                    .style('fill', '#94a3b8')
                                    .text(city);
                            });
                        } else {
                            // Single-line label for single endpoints
                            labelsLayer.append('text')
                                .attr('class', 'endpoint-label')
                                .attr('x', position.x)
                                .attr('y', position.y)
                                .attr('text-anchor', position.anchor)
                                .classed('dimmed', isFiltered && this.selectedEndpoint !== node.region_id)
                                .style('font-size', position.reducedFont ? '10px' : '12px')
                                .text(node.label);
                        }

                        // Add leader line if label was repositioned far from marker
                        if (position.needsLeaderLine) {
                            labelsLayer.append('line')
                                .attr('x1', node.x)
                                .attr('y1', node.y)
                                .attr('x2', position.x)
                                .attr('y2', position.y - 4)
                                .attr('stroke', '#64748b')
                                .attr('stroke-width', 0.5)
                                .attr('stroke-dasharray', '2,2')
                                .attr('opacity', 0.5);
                        }

                        placedLabels.push(position.bbox);
                    });
                }
            }
        }
    </script>
</body>
</html>
