<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PIA Router - Geographic Topology</title>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/topojson-client@3"></script>
    <style>
        /* Prevent scrolling on main viewport */
        html, body {
            overflow-x: hidden;
            max-width: 100vw;
            background: #0a0e1a;
        }

        /* Topology container */
        #topology-graph {
            background: linear-gradient(135deg, #0a0e1a 0%, #0f172a 100%);
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        /* World map layer */
        .map-layer path {
            fill: #1e3a5f;
            stroke: #334155;
            stroke-width: 0.5px;
            opacity: 0.25;
        }

        /* Mesh connection lines - 3D effect with shadow */
        .network-link-mesh {
            stroke: #475569;
            stroke-width: 1;
            stroke-dasharray: 4 4;
            fill: none;
            opacity: 0.3;
            filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.4));
        }

        .network-link-mesh.dimmed {
            opacity: 0.1;
        }

        /* VPN route lines - curved paths */
        .network-link-vpn {
            stroke: #60a5fa;
            stroke-width: 2;
            fill: none;
            opacity: 0.7;
            stroke-dasharray: 6 4;
            animation: dash-route 20s linear infinite;
        }

        .network-link-vpn.dimmed {
            opacity: 0.2;
            stroke: #475569;
        }

        .network-link-vpn:hover,
        .network-link-vpn.highlighted {
            stroke: #fbbf24;
            stroke-width: 3;
            opacity: 1;
            filter: drop-shadow(0 0 4px rgba(251, 191, 36, 0.8));
        }

        @keyframes dash-route {
            to {
                stroke-dashoffset: -200;
            }
        }

        /* Endpoint nodes (geographic PIA servers) - smaller with glow */
        .endpoint-node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .endpoint-node circle {
            filter: drop-shadow(0 0 6px rgba(16, 185, 129, 0.5));
        }

        .endpoint-node.dimmed circle {
            opacity: 0.3;
            filter: drop-shadow(0 0 2px rgba(16, 185, 129, 0.2));
        }

        .endpoint-node:hover circle {
            transform: scale(1.2);
            filter: drop-shadow(0 0 10px rgba(16, 185, 129, 0.8));
        }

        .endpoint-node.selected circle {
            filter: brightness(1.3) drop-shadow(0 0 12px rgba(251, 191, 36, 0.9));
        }

        /* Mesh nodes (Tailscale devices) - 3D depth with shadows */
        .mesh-node {
            cursor: pointer;
            transition: all 0.3s ease;
            filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.5));
        }

        .mesh-node.dimmed {
            opacity: 0.3;
        }

        .mesh-node:hover {
            filter: brightness(1.2) drop-shadow(0 6px 12px rgba(0, 0, 0, 0.6));
        }

        .mesh-node.selected {
            filter: brightness(1.5) drop-shadow(0 0 12px rgba(59, 130, 246, 0.8));
        }

        /* Labels with dark halo for readability */
        .endpoint-label {
            font-size: 11px;
            font-weight: 600;
            fill: #ffffff;
            paint-order: stroke;
            stroke: #000000;
            stroke-width: 3px;
            stroke-linecap: round;
            stroke-linejoin: round;
            pointer-events: none;
        }

        .endpoint-label.dimmed {
            opacity: 0.3;
        }

        .mesh-label {
            font-size: 10px;
            font-weight: 500;
            fill: #f1f5f9;
            opacity: 1;
            paint-order: stroke;
            stroke: #000000;
            stroke-width: 2.5px;
            stroke-linecap: round;
            stroke-linejoin: round;
            pointer-events: none;
        }

        .mesh-label.dimmed {
            opacity: 0.3;
        }

        /* All Endpoints pill */
        .all-endpoints-pill {
            background: linear-gradient(135deg, #1e293b 0%, #334155 100%);
            border: 1px solid #475569;
            transition: all 0.3s ease;
        }

        .all-endpoints-pill.active {
            background: linear-gradient(135deg, #1e40af 0%, #2563eb 100%);
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
        }

        .all-endpoints-pill:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        /* Endpoint pill styles */
        .endpoint-pill {
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .endpoint-pill:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .endpoint-pill.active {
            background: linear-gradient(135deg, #1e40af 0%, #2563eb 100%);
            border-color: #3b82f6;
            box-shadow: 0 0 0 2px rgba(59, 130, 246, 0.3);
        }

        /* Map expand toggle button */
        .expand-toggle {
            position: absolute;
            top: 12px;
            right: 12px;
            z-index: 10;
            background: rgba(30, 41, 59, 0.9);
            border: 1px solid #475569;
            border-radius: 6px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .expand-toggle:hover {
            background: rgba(51, 65, 85, 0.9);
            border-color: #64748b;
        }

        /* Device table styles */
        .device-table {
            font-size: 14px;
        }

        .device-row {
            height: 40px;
            transition: background-color 0.2s ease;
        }

        .device-row:hover {
            background-color: rgba(59, 130, 246, 0.1);
        }

        .device-row.selected {
            background-color: rgba(59, 130, 246, 0.2);
        }

        /* Status indicators */
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        /* Custom scrollbar for device table */
        .device-table-container::-webkit-scrollbar {
            width: 6px;
        }

        .device-table-container::-webkit-scrollbar-track {
            background: #1e293b;
        }

        .device-table-container::-webkit-scrollbar-thumb {
            background: #475569;
            border-radius: 3px;
        }

        /* Transition for layout changes */
        .topology-container,
        .table-container {
            transition: width 0.3s ease;
        }
    </style>
</head>
<body class="bg-slate-950 text-slate-100" x-data="app()" x-init="init()">
    <!-- Header (60px) -->
    <header class="bg-slate-900 border-b border-slate-800 px-6 py-3">
        <div class="flex items-center justify-between">
            <h1 class="text-xl font-bold text-white">PIA Router - Geographic Topology</h1>
            <div class="flex items-center space-x-6">
                <!-- Compact Status Indicators -->
                <div class="flex items-center space-x-2">
                    <div :class="vpnStatus.active_count > 0 ? 'bg-green-500' : 'bg-slate-500'" class="status-dot"></div>
                    <span class="text-sm text-slate-300"><span x-text="vpnStatus.active_count"></span> VPN</span>
                </div>
                <div class="flex items-center space-x-2">
                    <div :class="tailscaleStatus.running ? 'bg-green-500' : 'bg-red-500'" class="status-dot"></div>
                    <span class="text-sm text-slate-300">Tailscale</span>
                </div>
                <div class="flex items-center space-x-2">
                    <div :class="systemHealth.healthy ? 'bg-green-500' : 'bg-yellow-500'" class="status-dot"></div>
                    <span class="text-sm text-slate-300">System</span>
                </div>
                <a href="/settings" class="text-blue-400 hover:text-blue-300 text-sm font-medium">Settings</a>
                <a href="/" class="text-slate-400 hover:text-slate-300 text-sm">Classic View</a>
            </div>
        </div>
    </header>

    <!-- Endpoint Pills (80px) -->
    <div class="bg-slate-900 border-b border-slate-800 px-6 py-3">
        <div class="flex items-center space-x-3 overflow-x-auto">
            <span class="text-sm text-slate-400 flex-shrink-0">Filter:</span>

            <!-- All Endpoints Pill -->
            <div
                class="all-endpoints-pill flex items-center space-x-2 rounded-lg px-4 py-2 flex-shrink-0"
                :class="selectedEndpoint === null ? 'active' : ''"
                @click="clearEndpointFilter()">
                <svg class="w-4 h-4 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3.055 11H5a2 2 0 012 2v1a2 2 0 002 2 2 2 0 012 2v2.945M8 3.935V5.5A2.5 2.5 0 0010.5 8h.5a2 2 0 012 2 2 2 0 104 0 2 2 0 012-2h1.064M15 20.488V18a2 2 0 012-2h3.064M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path>
                </svg>
                <span class="font-semibold text-white text-sm">All Endpoints</span>
            </div>

            <!-- Endpoint Pills -->
            <template x-for="conn in vpnStatus.connections" :key="conn.region_id">
                <div
                    class="endpoint-pill flex items-center space-x-3 bg-slate-800 border border-slate-700 rounded-lg px-4 py-2 flex-shrink-0"
                    :class="selectedEndpoint === conn.region_id ? 'active' : ''"
                    @click="selectEndpointFilter(conn.region_id)">
                    <div class="w-2 h-2 rounded-full bg-green-500"></div>
                    <span class="font-medium text-white" x-text="conn.region_name"></span>
                    <span class="text-slate-400 text-sm">
                        <span x-text="devices.filter(d => d.region_id === conn.region_id && d.routing_enabled).length"></span> devices
                    </span>
                </div>
            </template>
            <div x-show="vpnStatus.connections.length === 0" class="text-slate-500 text-sm">No active VPN connections</div>
        </div>
    </div>

    <!-- Main Content: Split View (Graph + Table) -->
    <main class="px-6 py-4" style="height: calc(100vh - 140px);">
        <div class="flex space-x-4 h-full">
            <!-- LEFT: Geographic Topology (expandable) -->
            <div class="topology-container flex-shrink-0 relative" :class="mapExpanded ? 'w-[85%]' : 'w-3/5'">
                <div class="bg-slate-900 rounded-lg border border-slate-800 p-4 h-full flex flex-col">
                    <div class="flex items-center justify-between mb-3">
                        <h2 class="text-lg font-semibold text-white">Network Topology</h2>

                        <!-- Expand/Collapse Toggle -->
                        <button
                            @click="mapExpanded = !mapExpanded"
                            class="expand-toggle"
                            :title="mapExpanded ? 'Collapse map' : 'Expand map'">
                            <svg x-show="!mapExpanded" class="w-5 h-5 text-slate-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 8V4m0 0h4M4 4l5 5m11-1V4m0 0h-4m4 0l-5 5M4 16v4m0 0h4m-4 0l5-5m11 5l-5-5m5 5v-4m0 4h-4"></path>
                            </svg>
                            <svg x-show="mapExpanded" class="w-5 h-5 text-slate-300" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </button>
                    </div>
                    <div id="topology-graph" class="flex-1 min-h-0"></div>
                </div>
            </div>

            <!-- RIGHT: Device Routing Table (collapsible) -->
            <div class="table-container flex-shrink-0" :class="mapExpanded ? 'w-[15%]' : 'w-2/5'">
                <div class="bg-slate-900 rounded-lg border border-slate-800 p-4 h-full flex flex-col">
                    <div class="flex items-center justify-between mb-3">
                        <h2 class="text-lg font-semibold text-white" x-show="!mapExpanded">Device Routing</h2>
                        <h2 class="text-sm font-semibold text-white" x-show="mapExpanded">Devices</h2>
                        <span class="text-sm text-slate-400"><span x-text="filteredDevices.length"></span><span x-show="!mapExpanded"> / <span x-text="devices.length"></span></span></span>
                    </div>

                    <!-- Scrollable table container -->
                    <div class="device-table-container flex-1 min-h-0 overflow-y-auto">
                        <table class="device-table w-full" x-show="!mapExpanded">
                            <thead class="sticky top-0 bg-slate-800 text-slate-300 text-xs uppercase">
                                <tr>
                                    <th class="px-3 py-2 text-left">Device</th>
                                    <th class="px-3 py-2 text-left">IP</th>
                                    <th class="px-3 py-2 text-left">Region</th>
                                    <th class="px-3 py-2 text-center">Route</th>
                                </tr>
                            </thead>
                            <tbody>
                                <template x-for="device in filteredDevices" :key="device.id">
                                    <tr
                                        class="device-row border-b border-slate-800"
                                        :class="selectedDevice === device.id ? 'selected' : ''"
                                        @click="selectDevice(device.id)">
                                        <td class="px-3 py-2">
                                            <div class="flex items-center space-x-2">
                                                <div :class="device.online ? 'bg-green-500' : 'bg-slate-500'" class="w-2 h-2 rounded-full"></div>
                                                <span class="font-medium text-white truncate" x-text="device.hostname"></span>
                                            </div>
                                        </td>
                                        <td class="px-3 py-2 text-slate-400 text-sm" x-text="device.ip_addresses[0]"></td>
                                        <td class="px-3 py-2">
                                            <select
                                                @click.stop
                                                @change="setDeviceRegion(device.id, $event.target.value)"
                                                class="bg-slate-800 border border-slate-700 rounded px-2 py-1 text-sm text-white w-full"
                                                :value="device.region_id || ''">
                                                <option value="">No VPN</option>
                                                <template x-for="region in regions" :key="region.id">
                                                    <option :value="region.id" x-text="`${region.name} (${region.country})`"></option>
                                                </template>
                                            </select>
                                        </td>
                                        <td class="px-3 py-2 text-center">
                                            <button
                                                @click.stop="toggleDeviceRouting(device.id)"
                                                :disabled="!device.region_id"
                                                class="w-8 h-8 rounded-full transition-colors"
                                                :class="device.routing_enabled ? 'bg-red-600 hover:bg-red-700' : (device.region_id ? 'bg-green-600 hover:bg-green-700' : 'bg-slate-700 cursor-not-allowed')"
                                                :title="device.routing_enabled ? 'Stop routing' : (device.region_id ? 'Start routing' : 'Select region first')">
                                                <!-- Play Icon -->
                                                <svg x-show="!device.routing_enabled" class="w-4 h-4 mx-auto" fill="currentColor" viewBox="0 0 24 24">
                                                    <path d="M8 5v14l11-7z"/>
                                                </svg>
                                                <!-- Stop Icon -->
                                                <svg x-show="device.routing_enabled" class="w-4 h-4 mx-auto" fill="currentColor" viewBox="0 0 24 24">
                                                    <path d="M6 6h12v12H6z"/>
                                                </svg>
                                            </button>
                                        </td>
                                    </tr>
                                </template>
                            </tbody>
                        </table>

                        <!-- Compact view when expanded -->
                        <div x-show="mapExpanded" class="space-y-2">
                            <template x-for="device in filteredDevices" :key="device.id">
                                <div
                                    class="p-2 bg-slate-800 rounded border border-slate-700 cursor-pointer hover:bg-slate-750"
                                    :class="selectedDevice === device.id ? 'bg-slate-700' : ''"
                                    @click="selectDevice(device.id)">
                                    <div class="flex items-center space-x-2">
                                        <div :class="device.online ? 'bg-green-500' : 'bg-slate-500'" class="w-2 h-2 rounded-full flex-shrink-0"></div>
                                        <span class="text-xs font-medium text-white truncate" x-text="device.hostname"></span>
                                    </div>
                                </div>
                            </template>
                        </div>

                        <div x-show="filteredDevices.length === 0" class="text-center py-8 text-slate-500 text-sm">
                            No devices found
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <script>
        // Geographic coordinates for PIA regions (CORRECTED)
        const REGION_COORDINATES = {
            'sg': { lat: 1.3521, lng: 103.8198, name: 'Singapore' },
            'singapore': { lat: 1.3521, lng: 103.8198, name: 'Singapore' },
            'kh': { lat: 11.5564, lng: 104.9282, name: 'Cambodia' },
            'cambodia': { lat: 11.5564, lng: 104.9282, name: 'Cambodia' },
            'alaska': { lat: 61.2181, lng: -149.9003, name: 'US Alaska' },
            'melbourne': { lat: -37.8136, lng: 144.9631, name: 'AU Melbourne' },
            'sydney': { lat: -33.8688, lng: 151.2093, name: 'AU Sydney' },
            'perth': { lat: -31.9505, lng: 115.8605, name: 'AU Perth' },
            'japan': { lat: 35.6762, lng: 139.6503, name: 'Japan' },
            'tokyo': { lat: 35.6762, lng: 139.6503, name: 'Japan' },
            'hong': { lat: 22.3193, lng: 114.1694, name: 'Hong Kong' },
            'india': { lat: 19.0760, lng: 72.8777, name: 'India' },
            'mumbai': { lat: 19.0760, lng: 72.8777, name: 'India' },
            'zealand': { lat: -36.8485, lng: 174.7633, name: 'New Zealand' },
            'auckland': { lat: -36.8485, lng: 174.7633, name: 'New Zealand' },
            'london': { lat: 51.5074, lng: -0.1278, name: 'UK London' },
            'uk': { lat: 51.5074, lng: -0.1278, name: 'UK' },
            'germany': { lat: 52.5200, lng: 13.4050, name: 'Germany' },
            'berlin': { lat: 52.5200, lng: 13.4050, name: 'Germany' },
            'france': { lat: 48.8566, lng: 2.3522, name: 'France' },
            'paris': { lat: 48.8566, lng: 2.3522, name: 'France' },
            'netherlands': { lat: 52.3676, lng: 4.9041, name: 'Netherlands' },
            'amsterdam': { lat: 52.3676, lng: 4.9041, name: 'Netherlands' },
            'california': { lat: 37.7749, lng: -122.4194, name: 'US California' },
            'newyork': { lat: 40.7128, lng: -74.0060, name: 'US New York' },
            'texas': { lat: 29.7604, lng: -95.3698, name: 'US Texas' },
            'houston': { lat: 29.7604, lng: -95.3698, name: 'US Texas' },
            'canada': { lat: 43.6532, lng: -79.3832, name: 'Canada' },
            'toronto': { lat: 43.6532, lng: -79.3832, name: 'Canada' },
            'brazil': { lat: -23.5505, lng: -46.6333, name: 'Brazil' },
            'paulo': { lat: -23.5505, lng: -46.6333, name: 'Brazil' },
            'africa': { lat: -33.9249, lng: 18.4241, name: 'South Africa' },
            'capetown': { lat: -33.9249, lng: 18.4241, name: 'South Africa' }
        };

        function app() {
            return {
                loading: false,
                vpnStatus: { active_count: 0, connections: [] },
                tailscaleStatus: { running: false, exit_node_enabled: false, hostname: null },
                systemHealth: { healthy: false, messages: [] },
                regions: [],
                devices: [],
                selectedEndpoint: null,  // null = "All Endpoints"
                selectedDevice: null,
                mapExpanded: false,
                pollInterval: null,
                networkGraph: null,
                resizeObserver: null,

                get filteredDevices() {
                    if (this.selectedEndpoint === null) return this.devices;
                    return this.devices.filter(d => d.region_id === this.selectedEndpoint && d.routing_enabled);
                },

                async init() {
                    await this.loadRegions();
                    await this.refreshStatus();
                    await this.initTopologyGraph();

                    // Poll status every 5 seconds
                    this.pollInterval = setInterval(() => {
                        this.refreshStatus();
                    }, 5000);

                    // Use ResizeObserver for auto-resize
                    const container = document.getElementById('topology-graph');
                    if (container) {
                        this.resizeObserver = new ResizeObserver(() => {
                            this.resizeTopologyGraph();
                        });
                        this.resizeObserver.observe(container);
                    }
                },

                async loadRegions() {
                    try {
                        const response = await fetch('/api/settings/regions');
                        const data = await response.json();
                        this.regions = data.regions;
                    } catch (error) {
                        console.error('Failed to load regions:', error);
                    }
                },

                async refreshStatus() {
                    await Promise.all([
                        this.loadVPNStatus(),
                        this.loadTailscaleStatus(),
                        this.loadSystemHealth(),
                        this.loadDevices()
                    ]);

                    this.$nextTick(() => {
                        this.updateTopologyGraph();
                    });
                },

                async loadVPNStatus() {
                    try {
                        const response = await fetch('/api/status/vpn');
                        this.vpnStatus = await response.json();
                    } catch (error) {
                        console.error('Failed to load VPN status:', error);
                        this.vpnStatus = { active_count: 0, connections: [] };
                    }
                },

                async loadTailscaleStatus() {
                    try {
                        const response = await fetch('/api/status/tailscale');
                        this.tailscaleStatus = await response.json();
                    } catch (error) {
                        console.error('Failed to load Tailscale status:', error);
                    }
                },

                async loadSystemHealth() {
                    try {
                        const response = await fetch('/api/status/health');
                        this.systemHealth = await response.json();
                    } catch (error) {
                        console.error('Failed to load system health:', error);
                    }
                },

                async loadDevices() {
                    try {
                        const response = await fetch('/api/devices');
                        const data = await response.json();
                        this.devices = data.devices;
                    } catch (error) {
                        console.error('Failed to load devices:', error);
                    }
                },

                async setDeviceRegion(deviceId, regionId) {
                    try {
                        const response = await fetch(`/api/devices/${deviceId}/region`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ region_id: regionId || null })
                        });

                        if (!response.ok) {
                            const error = await response.json();
                            alert('Failed to set device region: ' + error.detail);
                        }

                        await this.loadDevices();
                        await this.loadVPNStatus();
                    } catch (error) {
                        alert('Failed to set device region: ' + error.message);
                    }
                },

                async toggleDeviceRouting(deviceId) {
                    try {
                        const response = await fetch(`/api/devices/${deviceId}/toggle`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({})
                        });

                        if (!response.ok) {
                            const error = await response.json();
                            alert('Failed to toggle device routing: ' + error.detail);
                        }

                        await this.loadDevices();
                        await this.loadVPNStatus();
                    } catch (error) {
                        alert('Failed to toggle device routing: ' + error.message);
                    }
                },

                clearEndpointFilter() {
                    this.selectedEndpoint = null;
                    this.$nextTick(() => {
                        this.updateTopologyGraph();
                    });
                },

                selectEndpointFilter(regionId) {
                    // Clicking same endpoint does NOT clear - must click "All Endpoints"
                    this.selectedEndpoint = regionId;
                    this.$nextTick(() => {
                        this.updateTopologyGraph();
                    });
                },

                selectDevice(deviceId) {
                    if (this.selectedDevice === deviceId) {
                        this.selectedDevice = null;
                    } else {
                        this.selectedDevice = deviceId;
                    }
                    this.$nextTick(() => {
                        this.updateTopologyGraph();
                    });
                },

                // Global View: Show entire world map (Pacific to Pacific, -180° to +180°)
                calculateMapCenter() {
                    // GLOBAL VIEW MODE: Always show the full world
                    // Center on prime meridian with slight eastward shift for balanced Pacific view
                    // Scale is fixed to ensure entire world (-180° to +180° longitude) is visible

                    return {
                        centerLon: 0,      // Prime meridian (Americas left, Europe/Africa center, Asia right)
                        centerLat: 10,     // Slight northern hemisphere bias for better land visibility
                        scale: 1.0         // Fixed scale - entire world always visible
                    };
                },

                async initTopologyGraph() {
                    const container = document.getElementById('topology-graph');
                    if (!container) return;

                    const width = container.clientWidth;
                    const height = container.clientHeight;

                    // Clear any existing SVG
                    d3.select('#topology-graph').selectAll('svg').remove();

                    // Create SVG
                    const svg = d3.select('#topology-graph')
                        .append('svg')
                        .attr('width', width)
                        .attr('height', height)
                        .attr('viewBox', [0, 0, width, height]);

                    // Global View: Fixed projection showing entire world
                    const { centerLon, centerLat, scale } = this.calculateMapCenter();

                    // Calculate scale to fit world map in viewport
                    // For Mercator projection, scale = viewport_width / (2π)
                    const globalScale = (width / (2 * Math.PI)) * 0.95; // 0.95 for 5% padding

                    // Create projection for Global View
                    const projection = d3.geoMercator()
                        .center([centerLon, centerLat])
                        .scale(globalScale)
                        .translate([width / 2, height / 2]);

                    // Create groups for layers (order matters for z-index)
                    const mapLayer = svg.append('g').attr('class', 'map-layer');
                    const routesLayer = svg.append('g').attr('class', 'routes-layer');
                    const meshLayer = svg.append('g').attr('class', 'mesh-layer');
                    const meshNodesLayer = svg.append('g').attr('class', 'mesh-nodes-layer');
                    const endpointNodesLayer = svg.append('g').attr('class', 'endpoint-nodes-layer');
                    const labelsLayer = svg.append('g').attr('class', 'labels-layer');

                    this.networkGraph = {
                        svg,
                        projection,
                        mapLayer,
                        routesLayer,
                        meshLayer,
                        meshNodesLayer,
                        endpointNodesLayer,
                        labelsLayer,
                        width,
                        height
                    };

                    // Load world map
                    await this.loadWorldMap();
                },

                async loadWorldMap() {
                    if (!this.networkGraph) return;

                    try {
                        // Load world topology data
                        const world = await d3.json('https://cdn.jsdelivr.net/npm/world-atlas@2/countries-110m.json');
                        const countries = topojson.feature(world, world.objects.countries);

                        // Draw countries with CORRECT projection
                        this.networkGraph.mapLayer
                            .selectAll('path')
                            .data(countries.features)
                            .enter()
                            .append('path')
                            .attr('d', d3.geoPath().projection(this.networkGraph.projection));

                    } catch (error) {
                        console.error('Failed to load world map:', error);
                    }
                },

                resizeTopologyGraph() {
                    if (!this.networkGraph) return;

                    const container = document.getElementById('topology-graph');
                    const newWidth = container.clientWidth;
                    const newHeight = container.clientHeight;

                    // Update SVG dimensions
                    this.networkGraph.svg
                        .attr('width', newWidth)
                        .attr('height', newHeight)
                        .attr('viewBox', [0, 0, newWidth, newHeight]);

                    // Recalculate smart center for new viewport
                    const { centerLon, centerLat, scale } = this.calculateMapCenter();

                    // Update projection with smart centering
                    this.networkGraph.projection
                        .center([centerLon, centerLat])
                        .scale((newWidth / 6.5) * scale)
                        .translate([newWidth / 2, newHeight / 2]);

                    // Update dimensions
                    this.networkGraph.width = newWidth;
                    this.networkGraph.height = newHeight;

                    // Redraw map
                    this.networkGraph.mapLayer
                        .selectAll('path')
                        .attr('d', d3.geoPath().projection(this.networkGraph.projection));

                    // Redraw topology
                    this.updateTopologyGraph();
                },

                getRegionCoordinates(regionId) {
                    // Try to match region ID to known coordinates (improved matching)
                    const searchId = regionId.toLowerCase();

                    for (const [key, coords] of Object.entries(REGION_COORDINATES)) {
                        if (searchId.includes(key) || key.includes(searchId)) {
                            return coords;
                        }
                    }

                    // Default to center if unknown
                    console.warn(`No coordinates found for region: ${regionId}`);
                    return { lat: 0, lng: 60, name: regionId };
                },

                // Generate curved path for VPN routes
                generateCurvedPath(source, target) {
                    const dx = target.x - source.x;
                    const dy = target.y - source.y;
                    const dr = Math.sqrt(dx * dx + dy * dy);

                    // Add curvature (10% of distance)
                    const curve = dr * 0.1;

                    return `M${source.x},${source.y} Q${(source.x + target.x) / 2},${(source.y + target.y) / 2 - curve} ${target.x},${target.y}`;
                },

                // Check for mesh/endpoint overlaps
                checkOverlap(meshNode, endpointNode, threshold = 40) {
                    const dx = meshNode.x - endpointNode.x;
                    const dy = meshNode.y - endpointNode.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    return distance < threshold;
                },

                updateTopologyGraph() {
                    if (!this.networkGraph) return;

                    const { svg, projection, routesLayer, meshLayer, meshNodesLayer, endpointNodesLayer, labelsLayer, width, height } = this.networkGraph;

                    // Build graph data
                    const nodes = [];
                    const links = [];

                    // GLOBAL VIEW: Smaller mesh (40-50% of viewport) centered on endpoint center of mass
                    let meshRadius = Math.min(width, height) * 0.22;  // Reduced from 0.26 to 0.22
                    const tiltAngle = 18; // degrees (increased from 15° for more depth)
                    const tiltRadians = (tiltAngle * Math.PI) / 180;

                    // Create endpoint nodes at CORRECT geographic locations
                    const endpointNodes = {};
                    this.vpnStatus.connections.forEach((conn) => {
                        const coords = this.getRegionCoordinates(conn.region_id);
                        const projectedCoords = projection([coords.lng, coords.lat]);

                        if (projectedCoords) {
                            const [x, y] = projectedCoords;

                            const endpointNode = {
                                id: `endpoint-${conn.region_id}`,
                                label: conn.region_name,
                                type: 'endpoint',
                                region_id: conn.region_id,
                                x: x,
                                y: y
                            };

                            nodes.push(endpointNode);
                            endpointNodes[conn.region_id] = endpointNode;
                        }
                    });

                    // Calculate mesh center based on endpoint center of mass (or viewport center if no endpoints)
                    let centerX, centerY;
                    const endpointList = Object.values(endpointNodes);

                    if (endpointList.length > 0) {
                        // Center mesh on the geographic center of mass of all endpoints
                        const sumX = endpointList.reduce((sum, ep) => sum + ep.x, 0);
                        const sumY = endpointList.reduce((sum, ep) => sum + ep.y, 0);
                        centerX = sumX / endpointList.length;
                        centerY = sumY / endpointList.length;
                    } else {
                        // Fallback to viewport center if no endpoints
                        centerX = width / 2;
                        centerY = height / 2;
                    }

                    // Calculate initial mesh positions
                    const deviceCount = this.devices.length;
                    const potentialDeviceNodes = [];

                    this.devices.forEach((device, idx) => {
                        const angle = (idx / deviceCount) * 2 * Math.PI - Math.PI / 2;

                        // Base position on circle
                        const baseX = centerX + meshRadius * Math.cos(angle);
                        const baseY = centerY + meshRadius * Math.sin(angle);

                        // Apply 3D tilt (y-axis rotation creates perspective)
                        const tiltOffset = Math.sin(angle) * meshRadius * Math.sin(tiltRadians) * 0.35;

                        potentialDeviceNodes.push({
                            id: `device-${device.id}`,
                            label: device.hostname,
                            type: 'device',
                            online: device.online,
                            region_id: device.region_id,
                            device_id: device.id,
                            routing_enabled: device.routing_enabled,
                            x: baseX,
                            y: baseY - tiltOffset,  // Tilt creates vertical offset
                            depth: Math.cos(angle),  // For depth sorting
                            angle: angle  // Store for potential rotation
                        });
                    });

                    // Check for overlaps and adjust radius if needed
                    let hasOverlap = false;

                    for (const meshNode of potentialDeviceNodes) {
                        for (const endpoint of endpointList) {
                            if (this.checkOverlap(meshNode, endpoint)) {
                                hasOverlap = true;
                                break;
                            }
                        }
                        if (hasOverlap) break;
                    }

                    // If overlap detected, reduce mesh radius slightly
                    if (hasOverlap) {
                        meshRadius *= 0.85;

                        // Recalculate positions with adjusted radius
                        potentialDeviceNodes.forEach((node, idx) => {
                            const angle = node.angle;
                            const baseX = centerX + meshRadius * Math.cos(angle);
                            const baseY = centerY + meshRadius * Math.sin(angle);
                            const tiltOffset = Math.sin(angle) * meshRadius * Math.sin(tiltRadians) * 0.35;

                            node.x = baseX;
                            node.y = baseY - tiltOffset;
                        });
                    }

                    // Add device nodes to main nodes array
                    nodes.push(...potentialDeviceNodes);

                    // Sort devices by depth for proper layering
                    const deviceNodes = nodes.filter(n => n.type === 'device').sort((a, b) => a.depth - b.depth);

                    // Add VPN route lines (device → endpoint) as CURVED paths
                    deviceNodes.forEach(deviceNode => {
                        if (deviceNode.region_id && deviceNode.routing_enabled) {
                            const endpointNode = endpointNodes[deviceNode.region_id];
                            if (endpointNode) {
                                links.push({
                                    source: deviceNode,
                                    target: endpointNode,
                                    type: 'vpn',
                                    device_id: deviceNode.device_id,
                                    region_id: deviceNode.region_id
                                });
                            }
                        }
                    });

                    // Add mesh connections between devices
                    for (let i = 0; i < deviceNodes.length; i++) {
                        for (let j = i + 1; j < deviceNodes.length; j++) {
                            links.push({
                                source: deviceNodes[i],
                                target: deviceNodes[j],
                                type: 'mesh'
                            });
                        }
                    }

                    // Determine dimming based on filter
                    const isFiltered = this.selectedEndpoint !== null;

                    // Update route lines with CURVED paths
                    const routeLink = routesLayer.selectAll('path')
                        .data(links.filter(l => l.type === 'vpn'), d => `${d.source.id}-${d.target.id}`);

                    routeLink.exit().remove();

                    routeLink.enter()
                        .append('path')
                        .attr('class', 'network-link-vpn')
                        .merge(routeLink)
                        .attr('d', d => this.generateCurvedPath(d.source, d.target))
                        .classed('dimmed', d => isFiltered && d.region_id !== this.selectedEndpoint);

                    // Update mesh lines
                    const meshLink = meshLayer.selectAll('line')
                        .data(links.filter(l => l.type === 'mesh'), d => `${d.source.id}-${d.target.id}`);

                    meshLink.exit().remove();

                    meshLink.enter()
                        .append('line')
                        .attr('class', 'network-link-mesh')
                        .merge(meshLink)
                        .attr('x1', d => d.source.x)
                        .attr('y1', d => d.source.y)
                        .attr('x2', d => d.target.x)
                        .attr('y2', d => d.target.y)
                        .classed('dimmed', d =>
                            isFiltered &&
                            d.source.region_id !== this.selectedEndpoint &&
                            d.target.region_id !== this.selectedEndpoint
                        );

                    // Update mesh nodes
                    const meshNode = meshNodesLayer.selectAll('g')
                        .data(deviceNodes, d => d.id);

                    meshNode.exit().remove();

                    const meshNodeEnter = meshNode.enter()
                        .append('g')
                        .attr('class', 'mesh-node')
                        .on('click', (event, d) => {
                            this.selectDevice(d.device_id);
                        });

                    meshNodeEnter.append('circle').attr('r', 14);  // Smaller radius

                    const allMeshNodes = meshNodeEnter.merge(meshNode);

                    allMeshNodes
                        .attr('transform', d => `translate(${d.x},${d.y})`)
                        .classed('selected', d => this.selectedDevice === d.device_id)
                        .classed('dimmed', d => isFiltered && d.region_id !== this.selectedEndpoint);

                    allMeshNodes.select('circle')
                        .attr('fill', d => d.online ? '#3b82f6' : '#6b7280')
                        .attr('stroke', '#fff')
                        .attr('stroke-width', 2);

                    // Update endpoint nodes (SMALLER size)
                    const endpointNode = endpointNodesLayer.selectAll('g')
                        .data(nodes.filter(n => n.type === 'endpoint'), d => d.id);

                    endpointNode.exit().remove();

                    const endpointNodeEnter = endpointNode.enter()
                        .append('g')
                        .attr('class', 'endpoint-node')
                        .on('click', (event, d) => {
                            this.selectEndpointFilter(d.region_id);
                        });

                    endpointNodeEnter.append('circle').attr('r', 6);  // Global View: smaller for spacious feeling

                    const allEndpointNodes = endpointNodeEnter.merge(endpointNode);

                    allEndpointNodes
                        .attr('transform', d => `translate(${d.x},${d.y})`)
                        .classed('selected', d => this.selectedEndpoint === d.region_id)
                        .classed('dimmed', d => isFiltered && this.selectedEndpoint !== d.region_id);

                    allEndpointNodes.select('circle')
                        .attr('fill', '#10b981')
                        .attr('stroke', '#fff')
                        .attr('stroke-width', 1.5);

                    // Update labels
                    labelsLayer.selectAll('*').remove();

                    // Mesh labels (with halo for readability)
                    deviceNodes.forEach(node => {
                        const labelText = node.label.length > 10 ? node.label.substring(0, 10) + '...' : node.label;

                        labelsLayer.append('text')
                            .attr('class', 'mesh-label')
                            .attr('x', node.x)
                            .attr('y', node.y + 26)
                            .attr('text-anchor', 'middle')
                            .classed('dimmed', isFiltered && node.region_id !== this.selectedEndpoint)
                            .text(labelText);
                    });

                    // Endpoint labels (with halo for readability)
                    nodes.filter(n => n.type === 'endpoint').forEach(node => {
                        labelsLayer.append('text')
                            .attr('class', 'endpoint-label')
                            .attr('x', node.x)
                            .attr('y', node.y + 24)
                            .attr('text-anchor', 'middle')
                            .classed('dimmed', isFiltered && this.selectedEndpoint !== node.region_id)
                            .text(node.label);
                    });
                }
            }
        }
    </script>
</body>
</html>
